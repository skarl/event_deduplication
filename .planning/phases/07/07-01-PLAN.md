---
phase: 07-accuracy-refinement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/event_dedup/config/synonyms.yaml
  - src/event_dedup/preprocessing/synonyms.py
  - src/event_dedup/preprocessing/normalizer.py
  - src/event_dedup/preprocessing/prefix_stripper.py
  - src/event_dedup/ingestion/file_processor.py
  - src/event_dedup/matching/config.py
  - src/event_dedup/matching/scorers/title_scorer.py
  - config/matching.yaml
  - scripts/renormalize_titles.py
  - tests/test_synonyms.py
  - tests/test_normalizer.py
  - tests/test_scorers.py
autonomous: true
requirements: [MTCH-07, MTCH-09]

must_haves:
  truths:
    - "German dialect synonyms (fasnet/fasnacht/fasching/fastnacht/karneval) are normalized to a single canonical form before fuzzy matching"
    - "Synonym replacement is applied at normalization time (O(events)) not scoring time (O(pairs))"
    - "Compound words containing synonym variants are handled correctly (e.g. fasnetsumzug -> fastnachtumzug)"
    - "Cross-source-type title pairs (artikel vs terminliste) use higher token_set_ratio weight to capture subset-match patterns"
    - "A re-normalization script updates existing title_normalized values in the database"
  artifacts:
    - path: "src/event_dedup/config/synonyms.yaml"
      provides: "German dialect synonym group definitions"
      contains: "synonym_groups"
    - path: "src/event_dedup/preprocessing/synonyms.py"
      provides: "Synonym loading and application functions"
      exports: ["load_synonym_map", "apply_synonyms"]
    - path: "src/event_dedup/matching/scorers/title_scorer.py"
      provides: "Source-type-aware title scoring with cross_source_type config"
    - path: "scripts/renormalize_titles.py"
      provides: "One-time script to re-normalize existing DB titles with synonyms"
    - path: "tests/test_synonyms.py"
      provides: "Unit tests for synonym loading and application"
  key_links:
    - from: "src/event_dedup/preprocessing/normalizer.py"
      to: "src/event_dedup/preprocessing/synonyms.py"
      via: "normalize_text calls apply_synonyms"
      pattern: "apply_synonyms"
    - from: "src/event_dedup/ingestion/file_processor.py"
      to: "src/event_dedup/preprocessing/synonyms.py"
      via: "FileProcessor loads synonym_map at init"
      pattern: "load_synonym_map"
    - from: "src/event_dedup/matching/scorers/title_scorer.py"
      to: "source_type field in event dicts"
      via: "title_score checks source_type to select blend config"
      pattern: "cross_source_type"
---

<objective>
Implement German dialect synonym dictionary (MTCH-07) and source-type-aware title scoring (MTCH-09).

Purpose: Synonym normalization closes the gap where dialect variants (fasnet vs fasnacht vs fastnacht vs karneval) reduce fuzzy match scores by 0.04-0.22 points, causing missed duplicates. Source-type-aware scoring fixes the asymmetric title length problem where terminliste "Preismaskenball" matches artikel "Preismaskenball mit Hemdglunker und Musikverein" at only 0.48 with token_sort_ratio but 1.00 with token_set_ratio.

Output: synonyms.yaml config, synonyms.py module, updated normalizer + title_scorer, re-normalization script, comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07/07-RESEARCH.md

@src/event_dedup/preprocessing/normalizer.py
@src/event_dedup/preprocessing/prefix_stripper.py
@src/event_dedup/preprocessing/synonyms.py
@src/event_dedup/ingestion/file_processor.py
@src/event_dedup/matching/config.py
@src/event_dedup/matching/scorers/title_scorer.py
@src/event_dedup/matching/pipeline.py
@src/event_dedup/worker/persistence.py
@config/matching.yaml
@tests/test_normalizer.py
@tests/test_scorers.py

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/event_dedup/matching/config.py:
```python
class TitleConfig(BaseModel):
    primary_weight: float = 0.7
    secondary_weight: float = 0.3
    blend_lower: float = 0.40
    blend_upper: float = 0.80

class MatchingConfig(BaseModel):
    scoring: ScoringWeights = ScoringWeights()
    thresholds: ThresholdConfig = ThresholdConfig()
    geo: GeoConfig = GeoConfig()
    date: DateConfig = DateConfig()
    title: TitleConfig = TitleConfig()
    cluster: ClusterConfig = ClusterConfig()
    canonical: CanonicalConfig = CanonicalConfig()
    ai: AIMatchingConfig = AIMatchingConfig()

def load_matching_config(path: Path) -> MatchingConfig
```

From src/event_dedup/preprocessing/normalizer.py:
```python
def normalize_text(text: str | None) -> str
def normalize_city(city: str | None, aliases: dict[str, str] | None = None) -> str
def load_city_aliases(config_path: Path) -> dict[str, str]
```

From src/event_dedup/matching/scorers/title_scorer.py:
```python
def title_score(event_a: dict, event_b: dict, config: TitleConfig | None = None) -> float
```

From src/event_dedup/ingestion/file_processor.py:
```python
class FileProcessor:
    def __init__(self, session_factory, dead_letter_dir, prefix_config_path=None, city_aliases_path=None)
    # Loads prefix_config and city_aliases at init
    # In process_file: stripped_title = strip_prefixes(title, self.prefix_config)
    #                   source_event.title_normalized = normalize_text(stripped_title)
```

From src/event_dedup/preprocessing/prefix_stripper.py:
```python
def normalize_title(title: str, prefix_config: PrefixConfig) -> str:
    stripped = strip_prefixes(title, prefix_config)
    return normalize_text(stripped)
```

Event dict schema (from persistence.py):
```python
{
    "id": str, "title": str, "title_normalized": str,
    "source_type": str,  # "artikel", "terminliste", "anzeige"
    "source_code": str, "categories": list[str],
    "blocking_keys": list[str], ...
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Synonym dictionary, loading module, and normalizer integration</name>
  <files>
    src/event_dedup/config/synonyms.yaml
    src/event_dedup/preprocessing/synonyms.py
    src/event_dedup/preprocessing/normalizer.py
    src/event_dedup/preprocessing/prefix_stripper.py
    src/event_dedup/ingestion/file_processor.py
    scripts/renormalize_titles.py
    tests/test_synonyms.py
    tests/test_normalizer.py
  </files>
  <action>
**1. Create `src/event_dedup/config/synonyms.yaml`:**

```yaml
# German dialect synonym groups for event title normalization.
# Each group maps variant terms to a single canonical form.
# Applied AFTER lowercasing and umlaut expansion, so all entries use expanded forms.
# Longest variants listed first within each group for correct replacement order.

synonym_groups:
  fastnacht:
    - fasnets    # compound prefix: "Fasnetsumzug" -> must match before "fasnet"
    - fasent
    - fasend
    - fasnet
    - fasnacht
    - fasching
    - karneval
  hemdglunker:
    - hemdklunker
    - hemdglunki
    - hendglunki
```

Note: All values are post-normalization forms (lowercase, umlauts already expanded). The canonical form (key) is NOT in the variants list -- it is the replacement target.

**2. Create `src/event_dedup/preprocessing/synonyms.py`:**

Two functions:

`load_synonym_map(config_path: Path) -> dict[str, str]`:
- Load synonyms.yaml, read `synonym_groups` dict
- Build flat mapping: `{variant: canonical}` for each group
- Sort the flat dict keys by length descending (longest first) at load time
- Return an `OrderedDict` or a regular dict where insertion order preserves longest-first (Python 3.7+ dicts preserve insertion order)
- If file doesn't exist, return empty dict
- Use same pattern as `load_city_aliases` (yaml.safe_load, handle None/empty)

`apply_synonyms(text: str, synonym_map: dict[str, str]) -> str`:
- If synonym_map is empty, return text unchanged
- Iterate over synonym_map items (already sorted longest-first by `load_synonym_map`)
- For each variant, canonical pair: `text = text.replace(variant, canonical)`
- Return modified text
- CRITICAL: Because dict is sorted longest-first at load time, "fasnets" is replaced before "fasnet", preventing partial matches in compound words like "fasnetsumzug"

**3. Update `src/event_dedup/preprocessing/normalizer.py`:**

Add optional `synonym_map` parameter to `normalize_text`:

```python
def normalize_text(text: str | None, synonym_map: dict[str, str] | None = None) -> str:
```

After the umlaut expansion and before whitespace normalization (or after whitespace normalization, before the final strip), add:

```python
    # Apply synonym replacement (after umlaut expansion so variants match)
    if synonym_map:
        from event_dedup.preprocessing.synonyms import apply_synonyms
        result = apply_synonyms(result, synonym_map)
```

Place the synonym step AFTER umlaut expansion (so "fasnet" matches regardless of original casing/umlauts) and AFTER whitespace normalization (so text is clean). The exact position should be after the `re.sub(r"\s+", " ", result).strip()` line and before the punctuation stripping line.

The import can be at the top of the file (preferred) rather than inline. Add:
```python
from event_dedup.preprocessing.synonyms import apply_synonyms
```

Ensure the existing `normalize_city` function signature is unchanged (it calls `normalize_text` without synonym_map, which is fine -- city names don't need synonym replacement).

**4. Update `src/event_dedup/preprocessing/prefix_stripper.py`:**

Update `normalize_title` to accept and pass through `synonym_map`:

```python
def normalize_title(title: str, prefix_config: PrefixConfig, synonym_map: dict[str, str] | None = None) -> str:
    stripped = strip_prefixes(title, prefix_config)
    return normalize_text(stripped, synonym_map=synonym_map)
```

**5. Update `src/event_dedup/ingestion/file_processor.py`:**

In `FileProcessor.__init__`:
- Add `synonyms_path: Path | None = None` parameter
- Load synonym map: `self.synonym_map = load_synonym_map(synonyms_path or config_dir / "synonyms.yaml")`
- Add import: `from event_dedup.preprocessing.synonyms import load_synonym_map`

In `FileProcessor.process_file`, change the normalization line from:
```python
source_event.title_normalized = normalize_text(stripped_title)
```
to:
```python
source_event.title_normalized = normalize_text(stripped_title, synonym_map=self.synonym_map)
```

Also update `short_description_normalized` similarly:
```python
source_event.short_description_normalized = (
    normalize_text(event.short_description, synonym_map=self.synonym_map) if event.short_description else None
)
```

**6. Create `scripts/renormalize_titles.py`:**

A standalone async script that:
- Connects to the database (using DATABASE_URL env var or default)
- Loads prefix_config and synonym_map using existing loader functions
- Queries all SourceEvent records
- For each: re-computes `title_normalized = normalize_text(strip_prefixes(evt.title, prefix_config), synonym_map=synonym_map)` and `short_description_normalized`
- Updates in batches of 100
- Prints progress (N events updated)
- Uses `asyncio.run()` as entry point

Pattern: follow existing script patterns in the project. Use `from event_dedup.db.session import create_async_engine` or similar if available, otherwise create engine directly with `create_async_engine(DATABASE_URL)`.

Check how other scripts connect to the DB by looking at existing scripts in `scripts/` directory. If no pattern exists, use:
```python
import asyncio, os
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import select, update
# ... load configs, connect, update in batches
```

Make it executable with `uv run python scripts/renormalize_titles.py`.

**7. Create `tests/test_synonyms.py`:**

Test `load_synonym_map`:
- Loading from a valid YAML file returns correct flat mapping
- Canonical form is NOT a key in the map (only variants are keys)
- Variants are sorted longest-first (iterate keys, verify each is >= length of next)
- Empty/missing file returns empty dict

Test `apply_synonyms`:
- "fasnet" -> "fastnacht" replacement
- "fasching" -> "fastnacht" replacement
- "karneval" -> "fastnacht" replacement
- "hemdklunker" -> "hemdglunker" replacement
- Compound words: "fasnetsumzug" -> "fastnachtumzug" (fasnets matches first)
- "fasnet-eroeffnung" -> "fastnacht-eroeffnung"
- Text with no synonyms returns unchanged
- Empty synonym_map returns text unchanged
- Multiple replacements in one string: "fasnet hemdklunker" -> "fastnacht hemdglunker"
- Canonical form in text is NOT replaced (e.g., "fastnacht" stays "fastnacht")

**8. Extend `tests/test_normalizer.py`:**

Add tests for synonym-aware normalization:
- `test_normalize_with_synonyms_fasnet`: `normalize_text("Fasnet-Eroeffnung", synonym_map)` returns text with "fastnacht" replacing "fasnet" (after umlaut expansion + lowercase)
- `test_normalize_with_synonyms_compound`: `normalize_text("Fasnetsumzug", synonym_map)` -> contains "fastnacht"
- `test_normalize_without_synonyms_unchanged`: `normalize_text("Fasnet", synonym_map=None)` -> "fasnet" (no replacement)
- `test_normalize_city_unaffected`: `normalize_city("Waldkirch")` still works (no synonym_map needed)

Use a fixture or helper that loads the real synonyms.yaml for these tests.
  </action>
  <verify>
    .venv/bin/python -m pytest tests/test_synonyms.py tests/test_normalizer.py -x --tb=short -q
  </verify>
  <done>
    - synonyms.yaml defines two synonym groups (fastnacht with 7 variants, hemdglunker with 3 variants)
    - load_synonym_map returns flat dict sorted longest-first
    - apply_synonyms correctly handles compound words (fasnetsumzug), hyphenated forms, and multiple replacements
    - normalize_text with synonym_map applies synonyms after umlaut expansion
    - FileProcessor loads synonym_map at init and passes to normalize_text during ingestion
    - normalize_title passes synonym_map through to normalize_text
    - renormalize_titles.py script exists and can be run to update existing DB records
    - All new and existing normalizer tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Source-type-aware title scoring with cross_source_type config</name>
  <files>
    src/event_dedup/matching/config.py
    src/event_dedup/matching/scorers/title_scorer.py
    config/matching.yaml
    tests/test_scorers.py
    tests/test_matching_config.py
    tests/test_pipeline.py
  </files>
  <action>
**1. Add `cross_source_type` to `TitleConfig` in `src/event_dedup/matching/config.py`:**

```python
class TitleConfig(BaseModel):
    """Parameters for title fuzzy-matching."""
    primary_weight: float = 0.7
    secondary_weight: float = 0.3
    blend_lower: float = 0.40
    blend_upper: float = 0.80
    cross_source_type: TitleConfig | None = None  # Override for artikel-terminliste pairs
```

Pydantic v2 supports self-referential models. Use `model_rebuild()` after the class definition if needed:
```python
TitleConfig.model_rebuild()
```

If self-reference causes issues with Pydantic v2, use a forward reference string `"TitleConfig"` and call `model_rebuild()`.

**2. Update `title_score()` in `src/event_dedup/matching/scorers/title_scorer.py`:**

```python
def title_score(
    event_a: dict, event_b: dict, config: TitleConfig | None = None
) -> float:
    if config is None:
        config = TitleConfig()

    title_a = (event_a.get("title") or "").strip()
    title_b = (event_b.get("title") or "").strip()

    if not title_a or not title_b:
        return 0.0

    # Determine effective config based on source types
    effective_config = config
    st_a = event_a.get("source_type", "")
    st_b = event_b.get("source_type", "")
    if (
        config.cross_source_type is not None
        and st_a != st_b
        and st_a in ("artikel", "terminliste")
        and st_b in ("artikel", "terminliste")
    ):
        effective_config = config.cross_source_type

    primary = fuzz.token_sort_ratio(title_a, title_b) / 100.0

    if effective_config.blend_lower <= primary <= effective_config.blend_upper:
        secondary = fuzz.token_set_ratio(title_a, title_b) / 100.0
        return effective_config.primary_weight * primary + effective_config.secondary_weight * secondary

    return primary
```

Key points:
- Source type check is optional: if `cross_source_type` is None (default), behavior is identical to current
- Only applies when one event is "artikel" and the other is "terminliste" -- same-type pairs and "anzeige" pairs use default config
- Falls back gracefully when source_type field is missing from event dicts

**3. Add `cross_source_type` section to `config/matching.yaml`:**

Under the existing `title:` section, add:

```yaml
title:
  primary_weight: 0.7
  secondary_weight: 0.3
  blend_lower: 0.40
  blend_upper: 0.80
  cross_source_type:
    primary_weight: 0.4     # Less weight on sort (penalizes length diff)
    secondary_weight: 0.6   # More weight on set (rewards token overlap)
    blend_lower: 0.25       # Wider blend range to catch more asymmetric matches
    blend_upper: 0.95
```

**4. Extend `tests/test_scorers.py` -- add new tests to `TestTitleScore`:**

```python
def test_cross_source_type_uses_override(self) -> None:
    """When source types differ (artikel vs terminliste), cross_source_type config is used."""
    cross_cfg = TitleConfig(
        primary_weight=0.4, secondary_weight=0.6,
        blend_lower=0.25, blend_upper=0.95,
    )
    cfg = TitleConfig(cross_source_type=cross_cfg)
    # Short terminliste title is subset of long artikel title
    a = {"title": "Preismaskenball", "source_type": "terminliste"}
    b = {"title": "Preismaskenball mit Hemdglunker und Musikverein", "source_type": "artikel"}
    score_cross = title_score(a, b, config=cfg)
    # Without cross config, would get ~0.636 (0.7*0.48 + 0.3*1.0)
    # With cross config, should get ~0.79 (0.4*0.48 + 0.6*1.0)
    score_default = title_score(a, b, config=TitleConfig())
    assert score_cross > score_default

def test_same_source_type_no_override(self) -> None:
    """When both events have same source type, default config is used."""
    cross_cfg = TitleConfig(
        primary_weight=0.1, secondary_weight=0.9,
        blend_lower=0.0, blend_upper=1.0,
    )
    cfg = TitleConfig(cross_source_type=cross_cfg)
    a = {"title": "Konzert im Park", "source_type": "artikel"}
    b = {"title": "Park Konzert", "source_type": "artikel"}
    score_with_cfg = title_score(a, b, config=cfg)
    score_default = title_score(a, b, config=TitleConfig())
    assert score_with_cfg == score_default

def test_missing_source_type_no_override(self) -> None:
    """When source_type is missing, default config is used."""
    cross_cfg = TitleConfig(
        primary_weight=0.1, secondary_weight=0.9,
        blend_lower=0.0, blend_upper=1.0,
    )
    cfg = TitleConfig(cross_source_type=cross_cfg)
    a = {"title": "Konzert im Park"}
    b = {"title": "Park Konzert"}
    score_with_cfg = title_score(a, b, config=cfg)
    score_default = title_score(a, b, config=TitleConfig())
    assert score_with_cfg == score_default

def test_anzeige_source_type_no_override(self) -> None:
    """Anzeige source type does not trigger cross_source_type override."""
    cross_cfg = TitleConfig(
        primary_weight=0.1, secondary_weight=0.9,
        blend_lower=0.0, blend_upper=1.0,
    )
    cfg = TitleConfig(cross_source_type=cross_cfg)
    a = {"title": "SC Freiburg Spiel", "source_type": "anzeige"}
    b = {"title": "SC Freiburg Bundesliga Spiel", "source_type": "artikel"}
    score_with_cfg = title_score(a, b, config=cfg)
    score_default = title_score(a, b, config=TitleConfig())
    assert score_with_cfg == score_default

def test_cross_source_type_wider_blend_catches_low_sort(self) -> None:
    """Cross-type config with wider blend range catches pairs that would be outside default range."""
    cross_cfg = TitleConfig(
        primary_weight=0.4, secondary_weight=0.6,
        blend_lower=0.25, blend_upper=0.95,
    )
    cfg = TitleConfig(cross_source_type=cross_cfg)
    # "Schiebeschlage" vs "Traditionelles Schiebeschlage mit gluehenden Holzscheiben"
    # token_sort_ratio ~ 0.40, token_set_ratio ~ 1.00
    # Default blend_lower is 0.40, so it's right at the edge
    # Cross config blend_lower 0.25 ensures it's included
    a = {"title": "Schiebeschlage", "source_type": "terminliste"}
    b = {"title": "Traditionelles Schiebeschlage mit gluehenden Holzscheiben", "source_type": "artikel"}
    score = title_score(a, b, config=cfg)
    assert score > 0.5  # Should be boosted by high set_ratio
```

**5. Extend `tests/test_matching_config.py`:**

Add a test that cross_source_type loads from YAML correctly:

```python
def test_cross_source_type_config(self, tmp_path: Path) -> None:
    """cross_source_type nested TitleConfig loads from YAML."""
    config_path = tmp_path / "matching.yaml"
    config_path.write_text(yaml.dump({
        "title": {
            "primary_weight": 0.7,
            "secondary_weight": 0.3,
            "cross_source_type": {
                "primary_weight": 0.4,
                "secondary_weight": 0.6,
                "blend_lower": 0.25,
                "blend_upper": 0.95,
            }
        }
    }))
    cfg = load_matching_config(config_path)
    assert cfg.title.cross_source_type is not None
    assert cfg.title.cross_source_type.primary_weight == 0.4
    assert cfg.title.cross_source_type.blend_lower == 0.25

def test_cross_source_type_none_by_default(self) -> None:
    """cross_source_type is None when not specified."""
    cfg = MatchingConfig()
    assert cfg.title.cross_source_type is None

def test_load_real_config_with_cross_source_type(self) -> None:
    """The shipped config/matching.yaml includes cross_source_type."""
    cfg = load_matching_config(Path("config/matching.yaml"))
    assert cfg.title.cross_source_type is not None
    assert cfg.title.cross_source_type.primary_weight == 0.4
    assert cfg.title.cross_source_type.secondary_weight == 0.6
```

**6. Verify existing `tests/test_pipeline.py` still passes:**

The `make_event` helper in test_pipeline.py does not include `source_type`, which is fine because `title_score` falls back to default config when source_type is missing. No changes needed to test_pipeline.py, but verify all existing tests pass unchanged. If any test breaks, the source_type fallback logic is incorrect.
  </action>
  <verify>
    .venv/bin/python -m pytest tests/test_scorers.py tests/test_matching_config.py tests/test_pipeline.py -x --tb=short -q
  </verify>
  <done>
    - TitleConfig has optional cross_source_type: TitleConfig | None field
    - title_score uses cross_source_type config when source types differ (artikel vs terminliste)
    - title_score falls back to default config when source_type is missing, same, or involves anzeige
    - config/matching.yaml includes cross_source_type with primary_weight=0.4, secondary_weight=0.6, blend_lower=0.25, blend_upper=0.95
    - All existing pipeline/scorer/config tests pass without modification
    - New tests verify cross-source-type behavior for artikel-terminliste pairs
  </done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:

```bash
.venv/bin/python -m pytest tests/ -x --tb=short -q
```

All existing tests must pass. New tests in test_synonyms.py, test_normalizer.py, test_scorers.py, and test_matching_config.py must also pass.

Verify synonym replacement improves specific title pairs:
```python
# Quick smoke test (can run in Python REPL)
from event_dedup.preprocessing.synonyms import load_synonym_map, apply_synonyms
from pathlib import Path

sm = load_synonym_map(Path("src/event_dedup/config/synonyms.yaml"))
assert apply_synonyms("fasnet-eroeffnung", sm) == "fastnacht-eroeffnung"
assert apply_synonyms("fasnetsumzug", sm) == "fastnachtumzug"
assert apply_synonyms("hemdklunkerumzug", sm) == "hemdglunkerumzug"
```
</verification>

<success_criteria>
1. Synonym dictionary defines groups for carnival terms (fastnacht, 7 variants) and hemdglunker (3 variants)
2. normalize_text with synonym_map replaces dialect variants with canonical forms
3. FileProcessor loads synonyms at init and applies during ingestion
4. title_score uses cross_source_type config for artikel-terminliste pairs
5. All 25+ existing test files pass without modification
6. New tests cover synonym loading, application, compound words, and cross-source-type scoring
</success_criteria>

<output>
After completion, create `.planning/phases/07/07-01-SUMMARY.md`
</output>
