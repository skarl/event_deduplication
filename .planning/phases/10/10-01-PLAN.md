# Phase 10, Plan 1: Backend — Time Gap Penalty & Venue Name Matching

## Goal
Add a 4th time proximity tier for 2h+ gaps in the date scorer and venue name matching in the geo scorer. Both reduce false positives for sequential events at the same or nearby locations. All new parameters are configurable via the dynamic config system.

## Requirements Covered
- **TGP-01**: Events on same date but 2+ hours apart receive steeper time penalty (factor 0.15 instead of 0.3)
- **TGP-02**: Time gap penalty parameters configurable via dynamic config
- **NEW**: Venue name matching in geo scorer to differentiate events at different venues in the same city

## Files to Modify
1. `src/event_dedup/matching/config.py` — add 2 fields to DateConfig, 2 fields to GeoConfig
2. `src/event_dedup/matching/scorers/date_scorer.py` — add 4th tier to `_time_proximity_factor()`
3. `src/event_dedup/matching/scorers/geo_scorer.py` — add venue name comparison
4. `config/matching.yaml` — document new parameters
5. `tests/test_scorers.py` — update existing tests, add new tests
6. `tests/test_matching_config.py` — update config default assertions

## Tasks

### Task 1: Config model extensions, scorer logic, and YAML

**Files:**
- `src/event_dedup/matching/config.py`
- `src/event_dedup/matching/scorers/date_scorer.py`
- `src/event_dedup/matching/scorers/geo_scorer.py`
- `config/matching.yaml`

**What:** Extend both config classes with new parameters, add the 4th time tier to the date scorer, and add venue name matching to the geo scorer.

**Details:**

**1. DateConfig (`config.py` line 52-58):**

Add two new fields after `far_factor`:
```python
class DateConfig(BaseModel):
    """Parameters for date/time overlap scoring."""

    time_tolerance_minutes: int = 30
    time_close_minutes: int = 90
    close_factor: float = 0.7
    far_factor: float = 0.3
    time_gap_penalty_hours: float = 2.0
    time_gap_penalty_factor: float = 0.15
```

**2. GeoConfig (`config.py` line 44-49):**

Add two new fields after `neutral_score`:
```python
class GeoConfig(BaseModel):
    """Parameters for geographic distance scoring."""

    max_distance_km: float = 10.0
    min_confidence: float = 0.85
    neutral_score: float = 0.5
    venue_match_distance_km: float = 1.0
    venue_mismatch_factor: float = 0.5
```

**3. Date scorer (`date_scorer.py` line 64-83):**

Modify `_time_proximity_factor()` to add the 4th tier. The current code returns `config.far_factor` as the catch-all. Change it to check the time gap threshold first:

Current (line 79-83):
```python
    if diff_minutes <= config.time_close_minutes:
        return config.close_factor
    return config.far_factor
```

Replace with:
```python
    if diff_minutes <= config.time_close_minutes:
        return config.close_factor
    if diff_minutes <= config.time_gap_penalty_hours * 60:
        return config.far_factor
    return config.time_gap_penalty_factor
```

This creates the 4-tier model:
- 0-30 min → 1.0 (exact)
- 30-90 min → 0.7 (close)
- 90-120 min → 0.3 (far)
- 120+ min → 0.15 (gap penalty)

**4. Geo scorer (`geo_scorer.py`):**

Add a venue name comparison function and integrate it into `geo_score()`.

Add import at top of file (after the existing imports):
```python
from rapidfuzz import fuzz
```

Add helper function after `_haversine_km()` (after line 24):
```python
def _venue_name_factor(
    name_a: str | None, name_b: str | None, config: GeoConfig
) -> float:
    """Compare venue names when events are in close proximity.

    Returns 1.0 when names match or are missing (benefit of the doubt).
    Returns ``config.venue_mismatch_factor`` when names clearly differ.
    """
    if not name_a or not name_b:
        return 1.0
    ratio = fuzz.token_sort_ratio(name_a.lower(), name_b.lower()) / 100.0
    if ratio >= 0.5:
        return 1.0
    return config.venue_mismatch_factor
```

Modify `geo_score()` — replace the final distance calculation (line 58-59):

Current:
```python
    dist = _haversine_km(lat_a, lon_a, lat_b, lon_b)
    return max(0.0, 1.0 - dist / config.max_distance_km)
```

Replace with:
```python
    dist = _haversine_km(lat_a, lon_a, lat_b, lon_b)
    score = max(0.0, 1.0 - dist / config.max_distance_km)

    # When events are in close proximity, compare venue names
    if dist < config.venue_match_distance_km:
        venue_f = _venue_name_factor(
            event_a.get("location_name"),
            event_b.get("location_name"),
            config,
        )
        score *= venue_f

    return score
```

**5. YAML config (`config/matching.yaml` line 27-31):**

Update the date and geo sections to document the new parameters:

Replace the date section:
```yaml
# --- Date/time scoring ---
date:
  time_tolerance_minutes: 30   # Times within this range are a perfect match
  time_close_minutes: 90       # Times within this range get close_factor
  close_factor: 0.7            # Multiplier for "close" time matches
  far_factor: 0.3              # Multiplier for times farther apart (up to gap threshold)
  time_gap_penalty_hours: 2.0  # Time gap (hours) beyond which penalty factor applies
  time_gap_penalty_factor: 0.15  # Multiplier for times beyond the gap threshold
```

Replace the geo section:
```yaml
# --- Geographic scoring ---
geo:
  max_distance_km: 10.0    # Events beyond this distance score 0.0
  min_confidence: 0.85     # Geo coordinates below this confidence are ignored
  neutral_score: 0.5       # Score when geo data is missing or low-confidence
  venue_match_distance_km: 1.0  # Compare venue names when events are closer than this
  venue_mismatch_factor: 0.5    # Multiply geo score by this when venue names differ
```

### Task 2: Tests

**Files:**
- `tests/test_scorers.py`
- `tests/test_matching_config.py`

**What:** Update existing tests to match the new 4-tier behavior and add new tests for the time gap penalty boundary and venue name matching.

**Details:**

**1. Update test_time_far_match (`test_scorers.py` line 61-67):**

This test uses a 4-hour (240 min) gap and currently expects 0.3. With the 4th tier, 4h > 2h → should now return 0.15.

Replace the entire test:
```python
    def test_time_far_match(self) -> None:
        cfg = DateConfig(time_tolerance_minutes=30, time_close_minutes=90, far_factor=0.3)
        a = {"dates": [{"date": "2026-03-01", "start_time": "10:00"}]}
        b = {"dates": [{"date": "2026-03-01", "start_time": "14:00"}]}
        # 240 min apart -> beyond 2h gap threshold -> time_gap_penalty_factor=0.15
        score = date_score(a, b, config=cfg)
        assert score == pytest.approx(0.15)
```

**2. Add new date scorer tests after `test_time_far_match` (after line 67):**

```python
    def test_time_gap_boundary_below(self) -> None:
        """119 minutes apart -> still within far_factor band (below 2h gap)."""
        a = {"dates": [{"date": "2026-03-01", "start_time": "10:00"}]}
        b = {"dates": [{"date": "2026-03-01", "start_time": "11:59"}]}
        score = date_score(a, b)
        assert score == pytest.approx(0.3)

    def test_time_gap_boundary_at(self) -> None:
        """120 minutes apart -> exactly at 2h gap threshold -> penalty factor."""
        a = {"dates": [{"date": "2026-03-01", "start_time": "10:00"}]}
        b = {"dates": [{"date": "2026-03-01", "start_time": "12:01"}]}
        score = date_score(a, b)
        assert score == pytest.approx(0.15)

    def test_time_gap_custom_threshold(self) -> None:
        """Custom 3h threshold: 150 min apart -> still far_factor."""
        cfg = DateConfig(time_gap_penalty_hours=3.0, time_gap_penalty_factor=0.1)
        a = {"dates": [{"date": "2026-03-01", "start_time": "10:00"}]}
        b = {"dates": [{"date": "2026-03-01", "start_time": "12:30"}]}
        # 150 min < 180 min (3h) -> far_factor=0.3
        score = date_score(a, b, config=cfg)
        assert score == pytest.approx(0.3)

    def test_time_gap_custom_threshold_exceeded(self) -> None:
        """Custom 3h threshold: 200 min apart -> penalty factor."""
        cfg = DateConfig(time_gap_penalty_hours=3.0, time_gap_penalty_factor=0.1)
        a = {"dates": [{"date": "2026-03-01", "start_time": "10:00"}]}
        b = {"dates": [{"date": "2026-03-01", "start_time": "13:21"}]}
        # 201 min > 180 min (3h) -> time_gap_penalty_factor=0.1
        score = date_score(a, b, config=cfg)
        assert score == pytest.approx(0.1)
```

**3. Add new geo scorer tests for venue name matching after the existing TestGeoScore class (after line 142):**

Add these tests inside the existing `TestGeoScore` class, after `test_custom_neutral_score`:

```python
    def test_same_venue_name(self) -> None:
        """Same coordinates and same venue name -> score 1.0."""
        a = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Stadttheater"}
        b = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Stadttheater"}
        assert geo_score(a, b) == 1.0

    def test_different_venue_name_close(self) -> None:
        """Same coordinates but different venue names -> reduced score."""
        cfg = GeoConfig(venue_mismatch_factor=0.5)
        a = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Stadttheater"}
        b = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Konzerthaus"}
        score = geo_score(a, b, config=cfg)
        assert score == pytest.approx(0.5)

    def test_venue_name_missing_one(self) -> None:
        """Same coordinates, one venue name missing -> benefit of doubt (1.0)."""
        a = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Stadttheater"}
        b = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95}
        assert geo_score(a, b) == 1.0

    def test_venue_name_missing_both(self) -> None:
        """Same coordinates, both venue names missing -> benefit of doubt (1.0)."""
        a = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95}
        b = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95}
        assert geo_score(a, b) == 1.0

    def test_venue_name_far_distance(self) -> None:
        """Far apart events: venue name NOT checked (distance alone determines score)."""
        cfg = GeoConfig(venue_match_distance_km=1.0, venue_mismatch_factor=0.5)
        a = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Stadttheater"}
        b = {"geo_latitude": 48.045, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Konzerthaus"}
        # ~5km apart -> beyond venue_match_distance_km -> venue factor NOT applied
        score_with_names = geo_score(a, b, config=cfg)
        score_without_names = geo_score(
            {k: v for k, v in a.items() if k != "location_name"},
            {k: v for k, v in b.items() if k != "location_name"},
            config=cfg,
        )
        assert score_with_names == score_without_names

    def test_similar_venue_name(self) -> None:
        """Same coordinates, similar venue names (ratio >= 0.5) -> no penalty."""
        a = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Marktplatz"}
        b = {"geo_latitude": 48.0, "geo_longitude": 7.8, "geo_confidence": 0.95, "location_name": "Marktplatz Waldkirch"}
        assert geo_score(a, b) == 1.0
```

**4. Update test_default_date (`test_matching_config.py` line 78-83):**

Add assertions for the new fields:
```python
    def test_default_date(self) -> None:
        cfg = MatchingConfig()
        assert cfg.date.time_tolerance_minutes == 30
        assert cfg.date.time_close_minutes == 90
        assert cfg.date.close_factor == 0.7
        assert cfg.date.far_factor == 0.3
        assert cfg.date.time_gap_penalty_hours == 2.0
        assert cfg.date.time_gap_penalty_factor == 0.15
```

**5. Update test_default_geo (`test_matching_config.py` line 72-76):**

Add assertions for the new fields:
```python
    def test_default_geo(self) -> None:
        cfg = MatchingConfig()
        assert cfg.geo.max_distance_km == 10.0
        assert cfg.geo.min_confidence == 0.85
        assert cfg.geo.neutral_score == 0.5
        assert cfg.geo.venue_match_distance_km == 1.0
        assert cfg.geo.venue_mismatch_factor == 0.5
```

**6. Update test_load_real_config (`test_matching_config.py` line 40-46):**

The shipped YAML now includes the new fields. No assertion changes needed since the test only checks a subset of fields. But optionally add:
```python
        assert cfg.date.time_gap_penalty_hours == 2.0
        assert cfg.geo.venue_match_distance_km == 1.0
```

## Verification

Run the scorer tests:
```bash
uv run pytest tests/test_scorers.py -v
```

Run the config tests:
```bash
uv run pytest tests/test_matching_config.py -v
```

Run the full test suite:
```bash
uv run pytest -x
```

Verify the config API includes new fields:
```bash
uv run python -c "from event_dedup.matching.config import MatchingConfig; c = MatchingConfig(); print(f'date gap: {c.date.time_gap_penalty_hours}h, factor: {c.date.time_gap_penalty_factor}'); print(f'venue dist: {c.geo.venue_match_distance_km}km, factor: {c.geo.venue_mismatch_factor}')"
```

## Dependencies
- Phase 8 complete (dynamic config system exists)
- RapidFuzz already a project dependency (used by title_scorer)
