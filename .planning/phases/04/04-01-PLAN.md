---
phase: 04-api-frontend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/event_dedup/api/app.py
  - src/event_dedup/api/deps.py
  - src/event_dedup/api/schemas.py
  - src/event_dedup/api/routes/__init__.py
  - src/event_dedup/api/routes/health.py
  - src/event_dedup/api/routes/canonical_events.py
  - config/alembic/versions/002_add_pg_trgm_and_date_columns.py
  - tests/test_api.py
autonomous: true
requirements: [UI-01, UI-02, UI-03, UI-04]

must_haves:
  truths:
    - "GET /api/canonical-events returns paginated list with total count, page number, and items"
    - "GET /api/canonical-events accepts q, city, date_from, date_to, category, page, size query params and filters correctly"
    - "GET /api/canonical-events/{id} returns full canonical event detail with all fields"
    - "GET /api/canonical-events/{id} includes source events with their full details and dates"
    - "GET /api/canonical-events/{id} includes match decisions with per-pair signal scores for the source event group"
    - "API returns 404 for non-existent canonical event IDs"
  artifacts:
    - path: "src/event_dedup/api/schemas.py"
      provides: "Pydantic response schemas for list/detail/source/match views"
      contains: "CanonicalEventSummary, CanonicalEventDetail, SourceEventSchema, MatchDecisionSchema, PaginatedResponse"
    - path: "src/event_dedup/api/routes/canonical_events.py"
      provides: "REST API endpoints for canonical events"
      exports: "router"
    - path: "src/event_dedup/api/deps.py"
      provides: "FastAPI dependency injection for async DB sessions"
      exports: "get_db"
    - path: "config/alembic/versions/002_add_pg_trgm_and_date_columns.py"
      provides: "pg_trgm extension, GIN index on title, first_date/last_date columns"
    - path: "tests/test_api.py"
      provides: "API endpoint tests using httpx TestClient"
  key_links:
    - from: "src/event_dedup/api/routes/canonical_events.py"
      to: "src/event_dedup/db/session.py"
      via: "deps.get_db dependency injection"
      pattern: "Depends\\(get_db\\)"
    - from: "src/event_dedup/api/routes/canonical_events.py"
      to: "src/event_dedup/models/canonical_event.py"
      via: "SQLAlchemy select with selectinload"
      pattern: "selectinload.*sources.*source_event"
    - from: "src/event_dedup/api/app.py"
      to: "src/event_dedup/api/routes/canonical_events.py"
      via: "FastAPI router include"
      pattern: "app\\.include_router"
---

<objective>
Build the FastAPI REST API that exposes canonical events with search, filtering, pagination, source-event drill-down, and match decision scores.

Purpose: The API is the data layer consumed by the React frontend (Plan 04-02). Without these endpoints, the frontend has nothing to display. This plan creates all backend routes, response schemas, database queries, and a migration for search optimization.

Output: Working REST API with 2 main endpoints (list + detail), Pydantic response schemas, async DB session injection, pg_trgm migration, and API tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04/04-RESEARCH.md

@src/event_dedup/api/app.py
@src/event_dedup/models/canonical_event.py
@src/event_dedup/models/canonical_event_source.py
@src/event_dedup/models/match_decision.py
@src/event_dedup/models/source_event.py
@src/event_dedup/models/event_date.py
@src/event_dedup/db/session.py
@src/event_dedup/db/engine.py
@src/event_dedup/config/settings.py
@src/event_dedup/worker/persistence.py
@tests/conftest.py

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/event_dedup/models/canonical_event.py:
```python
class CanonicalEvent(Base):
    __tablename__ = "canonical_events"
    id: Mapped[int] (primary_key)
    title: Mapped[str]
    short_description: Mapped[str | None]
    description: Mapped[str | None]
    highlights: Mapped[list | None] (JSON)
    location_name: Mapped[str | None]
    location_city: Mapped[str | None]
    location_district: Mapped[str | None]
    location_street: Mapped[str | None]
    location_zipcode: Mapped[str | None]
    geo_latitude: Mapped[float | None]
    geo_longitude: Mapped[float | None]
    geo_confidence: Mapped[float | None]
    dates: Mapped[list | None] (JSON)
    categories: Mapped[list | None] (JSON)
    is_family_event: Mapped[bool | None]
    is_child_focused: Mapped[bool | None]
    admission_free: Mapped[bool | None]
    field_provenance: Mapped[dict | None] (JSON)
    source_count: Mapped[int]
    match_confidence: Mapped[float | None]
    needs_review: Mapped[bool]
    version: Mapped[int]
    created_at: Mapped[datetime]
    updated_at: Mapped[datetime]
    sources: Mapped[list[CanonicalEventSource]] (relationship)
```

From src/event_dedup/models/canonical_event_source.py:
```python
class CanonicalEventSource(Base):
    __tablename__ = "canonical_event_sources"
    id: Mapped[int] (primary_key)
    canonical_event_id: Mapped[int] (FK -> canonical_events.id)
    source_event_id: Mapped[str] (FK -> source_events.id)
    added_at: Mapped[datetime]
    canonical_event: Mapped[CanonicalEvent] (relationship)
    source_event: Mapped[SourceEvent] (relationship)
```

From src/event_dedup/models/source_event.py:
```python
class SourceEvent(Base):
    __tablename__ = "source_events"
    id: Mapped[str] (primary_key, natural key: "pdf-{hash}-{batch}-{index}")
    title: Mapped[str]
    short_description: Mapped[str | None]
    description: Mapped[str | None]
    highlights: Mapped[list | None] (JSON)
    location_name/city/district/street/street_no/zipcode: Mapped[str | None]
    geo_latitude/longitude/confidence: Mapped[float | None]
    source_type: Mapped[str]  # "artikel" or "terminliste"
    source_code: Mapped[str]
    categories: Mapped[list | None] (JSON)
    is_family_event/is_child_focused/admission_free: Mapped[bool | None]
    dates: Mapped[list[EventDate]] (relationship)
```

From src/event_dedup/models/match_decision.py:
```python
class MatchDecision(Base):
    __tablename__ = "match_decisions"
    id: Mapped[int] (primary_key)
    source_event_id_a: Mapped[str] (FK, canonical ordering: a < b)
    source_event_id_b: Mapped[str] (FK)
    combined_score/date_score/geo_score/title_score/description_score: Mapped[float]
    decision: Mapped[str]  # "match", "no_match", "ambiguous"
    tier: Mapped[str]  # "deterministic"
```

From src/event_dedup/models/event_date.py:
```python
class EventDate(Base):
    __tablename__ = "event_dates"
    id: Mapped[int] (primary_key)
    event_id: Mapped[str] (FK -> source_events.id)
    date: Mapped[dt.date]
    start_time: Mapped[dt.time | None]
    end_time: Mapped[dt.time | None]
    end_date: Mapped[dt.date | None]
```

From src/event_dedup/db/session.py:
```python
def get_session_factory() -> async_sessionmaker[AsyncSession]
async def get_session() -> AsyncGenerator[AsyncSession, None]  # context manager
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: API schemas, dependency injection, and route structure</name>
  <files>
    src/event_dedup/api/schemas.py
    src/event_dedup/api/deps.py
    src/event_dedup/api/routes/__init__.py
    src/event_dedup/api/routes/health.py
    src/event_dedup/api/routes/canonical_events.py
    src/event_dedup/api/app.py
  </files>
  <action>
    **1. Create `src/event_dedup/api/schemas.py`** with Pydantic response models using `model_config = ConfigDict(from_attributes=True)`:

    - `EventDateSchema`: date (str), start_time (str|None), end_time (str|None), end_date (str|None)
    - `SourceEventSummary`: id (str), title, source_type, source_code, location_city (str|None). Lightweight for list context.
    - `SourceEventDetail`: Full source event fields -- id, title, short_description, description, highlights, location_name/city/district/street/street_no/zipcode, geo_latitude/longitude/confidence, source_type, source_code, categories, is_family_event/is_child_focused/admission_free, dates (list[EventDateSchema]). Used in drill-down view.
    - `MatchDecisionSchema`: id, source_event_id_a, source_event_id_b, combined_score, date_score, geo_score, title_score, description_score, decision, tier.
    - `CanonicalEventSummary`: id, title, location_city (str|None), dates (list|None), categories (list|None), source_count, match_confidence (float|None), needs_review (bool). For the list view (UI-01).
    - `CanonicalEventDetail`: All CanonicalEvent fields PLUS `sources` (list of `SourceEventDetail`) AND `match_decisions` (list of `MatchDecisionSchema`). For the detail view (UI-02, UI-03, UI-04).
    - `PaginatedResponse` (generic, using `Generic[T]`): items (list[T]), total (int), page (int), size (int), pages (int).

    For `CanonicalEventDetail`, the `sources` field and `match_decisions` field are NOT from ORM `from_attributes` directly -- they will be populated manually in the route handler. Use `model_config = ConfigDict(from_attributes=True)` for the base fields but handle nested objects explicitly.

    **2. Create `src/event_dedup/api/deps.py`** with FastAPI dependency:

    ```python
    from collections.abc import AsyncGenerator
    from fastapi import Depends
    from sqlalchemy.ext.asyncio import AsyncSession
    from event_dedup.db.session import get_session_factory

    async def get_db() -> AsyncGenerator[AsyncSession, None]:
        factory = get_session_factory()
        async with factory() as session:
            yield session
    ```

    **3. Create `src/event_dedup/api/routes/__init__.py`** (empty).

    **4. Create `src/event_dedup/api/routes/health.py`** -- move the existing `/health` endpoint from `app.py` into a router:

    ```python
    from fastapi import APIRouter
    router = APIRouter()

    @router.get("/health")
    async def health() -> dict:
        return {"status": "ok"}
    ```

    **5. Create `src/event_dedup/api/routes/canonical_events.py`** with two endpoints on an `APIRouter(prefix="/api/canonical-events", tags=["canonical-events"])`:

    **GET /api/canonical-events** (list endpoint for UI-01):
    - Query params: `q: str | None = None` (title search via ILIKE), `city: str | None = None` (ILIKE), `date_from: date | None = None`, `date_to: date | None = None`, `category: str | None = None`, `page: int = Query(default=1, ge=1)`, `size: int = Query(default=20, ge=1, le=100)`.
    - Build dynamic `select(CanonicalEvent)` statement:
      - If `q`: `.where(CanonicalEvent.title.ilike(f"%{q}%"))`
      - If `city`: `.where(CanonicalEvent.location_city.ilike(f"%{city}%"))`
      - If `date_from`: `.where(CanonicalEvent.first_date >= date_from)` (uses new column from migration)
      - If `date_to`: `.where(CanonicalEvent.last_date <= date_to)` (uses new column from migration)
      - If `category`: Use text-based JSON contains approach that works with both PG and SQLite: `.where(sa.cast(CanonicalEvent.categories, sa.String).ilike(f"%{category}%"))`. NOTE: This is a pragmatic approach -- full JSON `@>` operator is PG-only and breaks SQLite tests. The ILIKE on JSON string works for category name substring matching at this scale.
    - Count total: `select(sa.func.count()).select_from(stmt.subquery())`
    - Paginate: `.offset((page - 1) * size).limit(size).order_by(CanonicalEvent.title)`
    - Return `PaginatedResponse[CanonicalEventSummary]`

    **GET /api/canonical-events/{event_id}** (detail endpoint for UI-02, UI-03, UI-04):
    - Path param: `event_id: int`
    - Query with eager loading:
      ```python
      stmt = (
          select(CanonicalEvent)
          .where(CanonicalEvent.id == event_id)
          .options(
              selectinload(CanonicalEvent.sources)
              .selectinload(CanonicalEventSource.source_event)
              .selectinload(SourceEvent.dates)
          )
      )
      ```
    - If not found, raise `HTTPException(status_code=404, detail="Canonical event not found")`
    - Collect source event IDs from the canonical's sources
    - Query match decisions where BOTH `source_event_id_a` AND `source_event_id_b` are in the source event ID set:
      ```python
      source_ids = [s.source_event_id for s in canonical.sources]
      if len(source_ids) >= 2:
          md_stmt = select(MatchDecision).where(
              MatchDecision.source_event_id_a.in_(source_ids),
              MatchDecision.source_event_id_b.in_(source_ids),
          )
          match_decisions = (await db.execute(md_stmt)).scalars().all()
      else:
          match_decisions = []
      ```
    - Build `CanonicalEventDetail` response: use `CanonicalEventDetail.model_validate(canonical)` for base fields, then manually set `sources` (list of `SourceEventDetail` built from each `ces.source_event`) and `match_decisions` (list of `MatchDecisionSchema`).
    - Return the `CanonicalEventDetail`

    **6. Update `src/event_dedup/api/app.py`**:
    - Import routers from `routes.health` and `routes.canonical_events`
    - Add `app.include_router(health_router)` and `app.include_router(canonical_events_router)`
    - Remove the inline `/health` handler
    - Add lifespan or startup event to initialize the DB engine (import `get_engine` from db.engine to warm up the connection pool)
    - Add CORS middleware for development: `CORSMiddleware` with `allow_origins=["http://localhost:5173"]` (Vite dev server), `allow_methods=["*"]`, `allow_headers=["*"]`. This is only needed for local dev -- in production Nginx proxies through same origin.
  </action>
  <verify>
    <automated>cd /Users/svenkarl/workspaces/event-deduplication && uv run python -c "from event_dedup.api.app import app; from event_dedup.api.schemas import CanonicalEventSummary, CanonicalEventDetail, PaginatedResponse; print('imports OK')"</automated>
  </verify>
  <done>
    - All Pydantic schemas importable with correct fields
    - FastAPI app includes both routers
    - /health endpoint still works at same path
    - Canonical events routes registered at /api/canonical-events
    - Dependency injection provides async DB sessions
  </done>
</task>

<task type="auto">
  <name>Task 2: Alembic migration for pg_trgm and date columns</name>
  <files>
    config/alembic/versions/002_add_pg_trgm_and_date_columns.py
    src/event_dedup/models/canonical_event.py
    src/event_dedup/worker/persistence.py
    src/event_dedup/canonical/synthesizer.py
  </files>
  <action>
    **1. Add `first_date` and `last_date` columns to `CanonicalEvent` model** in `src/event_dedup/models/canonical_event.py`:

    ```python
    import datetime as dt
    # Add after the existing `dates` field:
    first_date: Mapped[dt.date | None] = mapped_column(sa.Date, nullable=True, index=True)
    last_date: Mapped[dt.date | None] = mapped_column(sa.Date, nullable=True, index=True)
    ```

    These denormalized date columns enable efficient range filtering without JSON extraction.

    **2. Update `src/event_dedup/canonical/synthesizer.py`** to populate `first_date` and `last_date`:

    After the `_union_dates` call that produces `result["dates"]`, add:
    ```python
    # Compute first_date / last_date for efficient range filtering
    all_dates = []
    for d in result["dates"]:
        date_str = d.get("date")
        if date_str:
            all_dates.append(date_str)
        end_date_str = d.get("end_date")
        if end_date_str:
            all_dates.append(end_date_str)
    if all_dates:
        all_dates.sort()
        result["first_date"] = all_dates[0]   # earliest date as string "YYYY-MM-DD"
        result["last_date"] = all_dates[-1]    # latest date as string "YYYY-MM-DD"
    else:
        result["first_date"] = None
        result["last_date"] = None
    ```

    **3. Update `src/event_dedup/worker/persistence.py`** to persist the new columns. In the `replace_canonical_events` function, inside the `CanonicalEvent(...)` constructor, add:

    ```python
    first_date=_parse_date(canonical_dict.get("first_date")),
    last_date=_parse_date(canonical_dict.get("last_date")),
    ```

    Add a helper at module level:
    ```python
    import datetime as dt

    def _parse_date(val: str | None) -> dt.date | None:
        if val is None:
            return None
        return dt.date.fromisoformat(val)
    ```

    **4. Create Alembic migration** `config/alembic/versions/002_add_pg_trgm_and_date_columns.py`:

    First check if a `versions` directory exists under `config/alembic/`. If not, create it with an `__init__.py`. Then create the migration:

    ```python
    """Add pg_trgm extension, GIN index on canonical_events.title, and first_date/last_date columns.

    Revision ID: 002
    Create Date: 2026-02-28
    """
    from alembic import op
    import sqlalchemy as sa

    revision = "002"
    down_revision = None  # Set to actual previous revision if one exists
    branch_labels = None
    depends_on = None

    def upgrade() -> None:
        # pg_trgm for fast title search (PostgreSQL only, no-op conceptually for other DBs)
        op.execute("CREATE EXTENSION IF NOT EXISTS pg_trgm")
        op.create_index(
            "ix_canonical_events_title_trgm",
            "canonical_events",
            ["title"],
            postgresql_using="gin",
            postgresql_ops={"title": "gin_trgm_ops"},
        )
        # Denormalized date columns for range filtering
        op.add_column("canonical_events", sa.Column("first_date", sa.Date(), nullable=True))
        op.add_column("canonical_events", sa.Column("last_date", sa.Date(), nullable=True))
        op.create_index("ix_canonical_events_first_date", "canonical_events", ["first_date"])
        op.create_index("ix_canonical_events_last_date", "canonical_events", ["last_date"])

    def downgrade() -> None:
        op.drop_index("ix_canonical_events_last_date")
        op.drop_index("ix_canonical_events_first_date")
        op.drop_column("canonical_events", "last_date")
        op.drop_column("canonical_events", "first_date")
        op.drop_index("ix_canonical_events_title_trgm")
        op.execute("DROP EXTENSION IF EXISTS pg_trgm")
    ```

    NOTE: Check for existing migrations in `config/alembic/versions/`. If a `001_...` migration exists, set `down_revision` to its revision ID. If no `versions/` directory exists, create it. The `down_revision` chain must be correct for Alembic to work.
  </action>
  <verify>
    <automated>cd /Users/svenkarl/workspaces/event-deduplication && uv run python -c "from event_dedup.models.canonical_event import CanonicalEvent; assert hasattr(CanonicalEvent, 'first_date'); assert hasattr(CanonicalEvent, 'last_date'); print('model OK')" && uv run python -c "from event_dedup.canonical.synthesizer import synthesize_canonical; r = synthesize_canonical([{'id':'a','title':'Test Event Title','dates':[{'date':'2026-03-01'}]}]); assert 'first_date' in r; print('synthesizer OK')"</automated>
  </verify>
  <done>
    - CanonicalEvent model has first_date and last_date columns (sa.Date, nullable, indexed)
    - Synthesizer populates first_date/last_date from the dates array
    - Persistence layer writes first_date/last_date when creating canonical events
    - Alembic migration file exists with pg_trgm extension, GIN index, and date columns
    - Migration has correct down_revision chain
  </done>
</task>

<task type="auto">
  <name>Task 3: API endpoint tests</name>
  <files>
    tests/test_api.py
    tests/conftest.py
  </files>
  <action>
    **1. Update `tests/conftest.py`** to add API test fixtures:

    Add a fixture that creates a FastAPI TestClient with an overridden DB dependency:

    ```python
    from httpx import ASGITransport, AsyncClient
    from event_dedup.api.app import app
    from event_dedup.api.deps import get_db

    @pytest.fixture
    async def api_client(test_engine, test_session_factory):
        """Async HTTP client hitting the FastAPI app with test DB."""
        async def override_get_db():
            async with test_session_factory() as session:
                yield session

        app.dependency_overrides[get_db] = override_get_db
        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://test") as client:
            yield client
        app.dependency_overrides.clear()
    ```

    Add a fixture that seeds test data (canonical events + source events + match decisions):

    ```python
    @pytest.fixture
    async def seeded_db(test_session_factory):
        """Seed the test DB with sample canonical events, sources, and match decisions."""
        from event_dedup.models.canonical_event import CanonicalEvent
        from event_dedup.models.source_event import SourceEvent
        from event_dedup.models.event_date import EventDate
        from event_dedup.models.canonical_event_source import CanonicalEventSource
        from event_dedup.models.match_decision import MatchDecision
        from event_dedup.models.file_ingestion import FileIngestion
        import datetime as dt

        async with test_session_factory() as session:
            async with session.begin():
                # Create file ingestion
                fi = FileIngestion(filename="test.json", source_key="test.pdf", event_count=2, status="completed")
                session.add(fi)
                await session.flush()

                # Create 2 source events
                se1 = SourceEvent(
                    id="pdf-aaa-0-0", file_ingestion_id=fi.id,
                    title="Fasching in Freiburg", source_type="artikel", source_code="bwb",
                    location_city="Freiburg", categories=["fasching"],
                    geo_latitude=48.0, geo_longitude=7.8, geo_confidence=0.9,
                )
                se2 = SourceEvent(
                    id="pdf-bbb-0-0", file_ingestion_id=fi.id,
                    title="Karneval in Freiburg", source_type="terminliste", source_code="rek",
                    location_city="Freiburg", categories=["karneval"],
                    geo_latitude=48.0, geo_longitude=7.8, geo_confidence=0.8,
                )
                session.add_all([se1, se2])

                # Add dates to source events
                ed1 = EventDate(event_id="pdf-aaa-0-0", date=dt.date(2026, 2, 15), start_time=dt.time(14, 0))
                ed2 = EventDate(event_id="pdf-bbb-0-0", date=dt.date(2026, 2, 15), start_time=dt.time(14, 30))
                session.add_all([ed1, ed2])

                # Create canonical event (merged)
                ce = CanonicalEvent(
                    title="Fasching in Freiburg",
                    short_description="Fasching celebration",
                    description="Annual Fasching celebration in the city center.",
                    location_city="Freiburg",
                    dates=[{"date": "2026-02-15", "start_time": "14:00"}],
                    categories=["fasching", "karneval"],
                    source_count=2,
                    match_confidence=0.85,
                    needs_review=False,
                    first_date=dt.date(2026, 2, 15),
                    last_date=dt.date(2026, 2, 15),
                    field_provenance={"title": "pdf-aaa-0-0"},
                )
                session.add(ce)
                await session.flush()

                # Link sources
                link1 = CanonicalEventSource(canonical_event_id=ce.id, source_event_id="pdf-aaa-0-0")
                link2 = CanonicalEventSource(canonical_event_id=ce.id, source_event_id="pdf-bbb-0-0")
                session.add_all([link1, link2])

                # Match decision (canonical ordering: aaa < bbb)
                md = MatchDecision(
                    source_event_id_a="pdf-aaa-0-0",
                    source_event_id_b="pdf-bbb-0-0",
                    combined_score=0.85,
                    date_score=0.95,
                    geo_score=1.0,
                    title_score=0.72,
                    description_score=0.60,
                    decision="match",
                    tier="deterministic",
                )
                session.add(md)

                # Create a second canonical event (singleton, no sources linked beyond itself)
                ce2 = CanonicalEvent(
                    title="Stadtfest Offenburg",
                    location_city="Offenburg",
                    dates=[{"date": "2026-06-20"}],
                    categories=["stadtfest"],
                    source_count=1,
                    needs_review=False,
                    first_date=dt.date(2026, 6, 20),
                    last_date=dt.date(2026, 6, 20),
                )
                session.add(ce2)
    ```

    **2. Create `tests/test_api.py`** with the following tests (all async, using `api_client` + `seeded_db` fixtures):

    - `test_health_endpoint`: GET /health returns 200 with `{"status": "ok"}`
    - `test_list_canonical_events`: GET /api/canonical-events returns paginated response with 2 items, total=2, page=1
    - `test_list_pagination`: GET /api/canonical-events?page=1&size=1 returns 1 item with total=2, pages=2
    - `test_list_filter_by_city`: GET /api/canonical-events?city=freiburg returns 1 item (Freiburg event)
    - `test_list_search_by_title`: GET /api/canonical-events?q=Fasching returns 1 item
    - `test_list_filter_by_date_range`: GET /api/canonical-events?date_from=2026-02-01&date_to=2026-03-01 returns 1 item (Freiburg is in Feb, Offenburg in June)
    - `test_list_filter_by_category`: GET /api/canonical-events?category=stadtfest returns 1 item (Offenburg)
    - `test_detail_canonical_event`: GET /api/canonical-events/{id} returns full detail with sources list (2 source events) and match_decisions list (1 decision)
    - `test_detail_includes_source_dates`: Assert the source events in the detail response include their dates
    - `test_detail_includes_match_scores`: Assert the match decision in the detail response has title_score, geo_score, date_score, description_score
    - `test_detail_not_found`: GET /api/canonical-events/9999 returns 404

    Use `pytest.mark.asyncio` and `await api_client.get(...)` pattern. Assert on response status codes and JSON structure.

    **Important:** The `seeded_db` fixture must be requested by each test that needs data (explicitly include it as a parameter). The `api_client` fixture automatically gets the test DB through dependency override.
  </action>
  <verify>
    <automated>cd /Users/svenkarl/workspaces/event-deduplication && uv run pytest tests/test_api.py -x -v 2>&1 | tail -30</automated>
  </verify>
  <done>
    - All 11 API tests pass
    - Health endpoint returns 200
    - List endpoint returns paginated results with correct structure
    - Filtering by city, title search, date range, and category all work correctly
    - Detail endpoint returns source events with dates and match decisions with signal scores
    - 404 returned for non-existent canonical events
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_api.py -x -v` -- all API tests pass
2. `uv run python -c "from event_dedup.api.app import app; print([r.path for r in app.routes])"` -- shows /health, /api/canonical-events, /api/canonical-events/{event_id}
3. `uv run python -c "from event_dedup.api.schemas import PaginatedResponse, CanonicalEventDetail; print('schemas OK')"` -- schemas importable
4. `uv run pytest tests/ -x --timeout=60` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
- FastAPI app serves /health, /api/canonical-events (list), /api/canonical-events/{id} (detail)
- List endpoint supports q, city, date_from, date_to, category, page, size query params
- Detail endpoint returns source events with dates and match decisions with per-pair signal scores
- All 11+ API tests pass
- No regressions in existing test suite
- Alembic migration ready for pg_trgm and first_date/last_date columns
</success_criteria>

<output>
After completion, create `.planning/phases/04/04-01-SUMMARY.md`
</output>
