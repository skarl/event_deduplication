# Phase 11, Plan 1: Backend — Multi-Filter, Sort, Size Cap, and Distinct-Value Endpoints

## Goal

Extend `GET /api/canonical-events` to support multi-value city/category filters, sort_by/sort_dir
parameters, and a raised size cap. Add two new read-only endpoints — `GET /api/canonical-events/categories`
and `GET /api/canonical-events/cities` — that return distinct values for the chip selector autocomplete.

## Requirements Covered

- **UIX-01**: `/categories` endpoint returns distinct category values from the JSON array column
- **UIX-02**: `/cities` endpoint returns distinct city values
- **UIX-03**: `sort_by` + `sort_dir` params with 7-column mapping and nullslast/nullsfirst
- **UIX-04**: `size` cap raised from `le=100` to `le=10000` (supports 200 and ALL=10000 from frontend)

## Files to Modify

1. `src/event_dedup/api/routes/canonical_events.py` — all backend changes
2. `tests/test_api.py` — new and updated tests

---

## Tasks

### Task 1: Add distinct-value endpoints and update list_canonical_events

**Files:**
- `src/event_dedup/api/routes/canonical_events.py`

**What:** Add the two new GET endpoints, update `list_canonical_events` to accept multi-value
city/category params, add sort_by/sort_dir support with nullslast/nullsfirst, and raise the size cap.

**Details:**

**1. New `/categories` and `/cities` endpoints (register BEFORE `/{event_id}`).**

The `/categories` endpoint fetches all non-null `categories` JSON-array column values, flattens
them in Python, deduplicates into a sorted list. The `/cities` endpoint uses a simple DISTINCT
SELECT on `location_city` ordered alphabetically.

Both use `router.get(...)` directly. Both accept only `db: AsyncSession = Depends(get_db)`.
No pagination needed — the full sorted list is returned.

Register both new routes between the existing `@router.get("")` route and the
existing `@router.get("/{event_id}", ...)` route — this is CRITICAL to avoid FastAPI
treating the string `"categories"` or `"cities"` as an `event_id` int.

```python
@router.get("/categories", response_model=list[str])
async def list_distinct_categories(
    db: AsyncSession = Depends(get_db),
) -> list[str]:
    """Return all distinct category values across all canonical events."""
    stmt = sa.select(CanonicalEvent.categories).where(
        CanonicalEvent.categories.is_not(None)
    )
    result = await db.execute(stmt)
    all_cats: set[str] = set()
    for (cats,) in result:
        if isinstance(cats, list):
            all_cats.update(cats)
    return sorted(all_cats)


@router.get("/cities", response_model=list[str])
async def list_distinct_cities(
    db: AsyncSession = Depends(get_db),
) -> list[str]:
    """Return all distinct city values across all canonical events."""
    stmt = (
        sa.select(CanonicalEvent.location_city)
        .where(CanonicalEvent.location_city.is_not(None))
        .distinct()
        .order_by(CanonicalEvent.location_city)
    )
    result = await db.execute(stmt)
    return [row[0] for row in result]
```

**2. Update `list_canonical_events` signature.**

Replace the current parameter block with:

```python
@router.get("", response_model=PaginatedResponse[CanonicalEventSummary])
async def list_canonical_events(
    db: AsyncSession = Depends(get_db),
    q: str | None = None,
    city: list[str] = Query(default=[]),
    date_from: dt.date | None = None,
    date_to: dt.date | None = None,
    category: list[str] = Query(default=[]),
    sort_by: str = Query(default="title"),
    sort_dir: str = Query(default="asc"),
    page: int = Query(default=1, ge=1),
    size: int = Query(default=25, ge=1, le=10000),
) -> PaginatedResponse[CanonicalEventSummary]:
```

**3. Update the filter block inside `list_canonical_events`.**

Replace the current single-value `if city:` and `if category:` branches:

```python
    if city:
        # OR semantics: event must match ANY selected city (ilike for case-insensitive)
        stmt = stmt.where(
            sa.or_(*[CanonicalEvent.location_city.ilike(f"%{c}%") for c in city])
        )
    if category:
        # AND semantics: event must have ALL selected categories
        for cat in category:
            stmt = stmt.where(
                sa.cast(CanonicalEvent.categories, sa.String).ilike(f"%{cat}%")
            )
```

**4. Add the sort block before the count query.**

Replace the existing hardcoded `.order_by(CanonicalEvent.title)` on the paginate line.
Add a sort_col_map and order_by BEFORE the count query, because the count uses `stmt.subquery()`:

```python
    # Sorting
    sort_col_map = {
        "title":        CanonicalEvent.title,
        "city":         CanonicalEvent.location_city,
        "date":         CanonicalEvent.first_date,
        "categories":   sa.cast(CanonicalEvent.categories, sa.String),
        "source_count": CanonicalEvent.source_count,
        "confidence":   CanonicalEvent.match_confidence,
        "review":       CanonicalEvent.needs_review,
    }
    sort_col = sort_col_map.get(sort_by, CanonicalEvent.title)
    if sort_dir == "desc":
        stmt = stmt.order_by(sa.nullslast(sort_col.desc()))
    else:
        stmt = stmt.order_by(sa.nullsfirst(sort_col.asc()))

    # Count total (after filters + order)
    count_stmt = sa.select(sa.func.count()).select_from(stmt.subquery())
    total = (await db.execute(count_stmt)).scalar_one()

    # Paginate
    stmt = stmt.offset((page - 1) * size).limit(size)
    result = await db.execute(stmt)
```

Remove the old `.order_by(CanonicalEvent.title)` that was previously inline on the paginate line.

**List[str] import:** FastAPI `Query(default=[])` with `list[str]` type hint does NOT require
importing `List` from typing — `list[str]` (lowercase) works in Python 3.10+ which this project
uses. No additional imports needed.

**Verification:**
```bash
cd /Users/svenkarl/workspaces/event-deduplication && uv run python -c "
from event_dedup.api.routes.canonical_events import router
routes = [r.path for r in router.routes]
print(routes)
# /categories and /cities must appear BEFORE /{event_id}
"
```

**Done:** File parses without errors, route list shows `/categories` and `/cities` before `/{event_id}`,
`list_canonical_events` signature has `city: list[str]`, `category: list[str]`, `sort_by`, `sort_dir`,
and `size` with `le=10000`.

---

### Task 2: Tests for new endpoints and updated list behavior

**Files:**
- `tests/test_api.py`

**What:** Add tests for the two new distinct-value endpoints, multi-value filtering, sorting, and
the new size cap. Update one existing test that now fails due to the default size changing from 20 to 25.

**Details:**

The `seeded_db` fixture has two canonical events:
- `Fasching in Freiburg` — city=Freiburg, categories=["fasching","karneval"]
- `Stadtfest Offenburg` — city=Offenburg, categories=["stadtfest"]

**1. Check if `test_list_canonical_events` needs updating.**

That test asserts `data["total"] == 2` — still correct. No change needed there.

**2. Add new tests at the end of `tests/test_api.py`:**

```python
# --- New Phase 11 tests ---

@pytest.mark.asyncio
async def test_list_distinct_categories(api_client, seeded_db):
    resp = await api_client.get("/api/canonical-events/categories")
    assert resp.status_code == 200
    cats = resp.json()
    assert isinstance(cats, list)
    assert "fasching" in cats
    assert "karneval" in cats
    assert "stadtfest" in cats
    assert cats == sorted(cats)  # must be sorted alphabetically


@pytest.mark.asyncio
async def test_list_distinct_cities(api_client, seeded_db):
    resp = await api_client.get("/api/canonical-events/cities")
    assert resp.status_code == 200
    cities = resp.json()
    assert isinstance(cities, list)
    assert "Freiburg" in cities
    assert "Offenburg" in cities
    assert cities == sorted(cities)


@pytest.mark.asyncio
async def test_categories_route_not_matched_as_event_id(api_client, seeded_db):
    """Ensure /categories is NOT interpreted as GET /{event_id} with event_id='categories'."""
    resp = await api_client.get("/api/canonical-events/categories")
    # Must be 200 (list), NOT 422 (validation error for non-int event_id)
    assert resp.status_code == 200


@pytest.mark.asyncio
async def test_list_multi_city_filter(api_client, seeded_db):
    resp = await api_client.get(
        "/api/canonical-events?city=Freiburg&city=Offenburg"
    )
    assert resp.status_code == 200
    data = resp.json()
    assert data["total"] == 2  # both cities returned (OR semantics)


@pytest.mark.asyncio
async def test_list_multi_category_and_semantics(api_client, seeded_db):
    # Both fasching AND karneval -> only Fasching event has both
    resp = await api_client.get(
        "/api/canonical-events?category=fasching&category=karneval"
    )
    assert resp.status_code == 200
    data = resp.json()
    assert data["total"] == 1
    assert data["items"][0]["title"] == "Fasching in Freiburg"


@pytest.mark.asyncio
async def test_list_sort_by_city_asc(api_client, seeded_db):
    resp = await api_client.get("/api/canonical-events?sort_by=city&sort_dir=asc")
    assert resp.status_code == 200
    data = resp.json()
    cities = [item["location_city"] for item in data["items"]]
    assert cities == sorted(cities)


@pytest.mark.asyncio
async def test_list_sort_by_city_desc(api_client, seeded_db):
    resp = await api_client.get("/api/canonical-events?sort_by=city&sort_dir=desc")
    assert resp.status_code == 200
    data = resp.json()
    cities = [item["location_city"] for item in data["items"]]
    assert cities == sorted(cities, reverse=True)


@pytest.mark.asyncio
async def test_list_size_200_accepted(api_client, seeded_db):
    """size=200 must not be rejected (previously capped at le=100)."""
    resp = await api_client.get("/api/canonical-events?size=200")
    assert resp.status_code == 200


@pytest.mark.asyncio
async def test_list_size_10000_accepted(api_client, seeded_db):
    """size=10000 (ALL sentinel) must be accepted."""
    resp = await api_client.get("/api/canonical-events?size=10000")
    assert resp.status_code == 200
    data = resp.json()
    assert data["total"] == 2
```

**Verification:**
```bash
cd /Users/svenkarl/workspaces/event-deduplication && uv run pytest tests/test_api.py -v
```

**Done:** All existing tests pass. All 9 new tests pass. `uv run pytest tests/test_api.py -v`
exits 0 with no failures.

---

## Verification

Run the full test suite to confirm no regressions:

```bash
cd /Users/svenkarl/workspaces/event-deduplication && uv run pytest tests/test_api.py -v
```

Smoke-check the API starts cleanly:

```bash
cd /Users/svenkarl/workspaces/event-deduplication && uv run python -c "
from event_dedup.api.routes.canonical_events import router
paths = [r.path for r in router.routes]
print('Routes:', paths)
cat_idx = paths.index('/api/canonical-events/categories')
id_idx  = paths.index('/api/canonical-events/{event_id}')
assert cat_idx < id_idx, '/categories must be registered before /{event_id}'
print('Route order OK')
"
```

## Dependencies

- Phase 10 complete (existing route and test infrastructure in place)
- No new Python packages required
