---
phase: 06-review-operations
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - frontend/src/types/index.ts
  - frontend/src/api/client.ts
  - frontend/src/hooks/useReview.ts
  - frontend/src/hooks/useDashboard.ts
  - frontend/src/components/ReviewQueue.tsx
  - frontend/src/components/SplitDialog.tsx
  - frontend/src/components/MergeDialog.tsx
  - frontend/src/components/Dashboard.tsx
  - frontend/src/components/AuditTrail.tsx
  - frontend/src/components/EventDetail.tsx
  - frontend/src/App.tsx
  - docker/nginx.conf
autonomous: true
requirements: [REV-01, REV-02, REV-03, REV-04, REV-05]

must_haves:
  truths:
    - "Review queue page at /review shows low-confidence events sorted by uncertainty, with pagination"
    - "Operator can click Split on a source event within EventDetail to detach it (creates new canonical by default, or assign to existing via search)"
    - "Operator can click Merge on EventDetail to combine with another canonical found via search dialog"
    - "Dashboard page at /dashboard shows file processing stats, match distribution bars, canonical summary, and daily processing trend"
    - "Audit trail section on EventDetail shows timestamped log of all manual operations for that canonical event"
    - "Navigation header includes links to Review Queue and Dashboard"
    - "After split/merge/dismiss, affected queries are invalidated and UI refreshes automatically"
    - "Nginx proxies /api/review/* and /api/dashboard/* and /api/audit-log* to the API container"
  artifacts:
    - path: "frontend/src/types/index.ts"
      provides: "Extended TypeScript types for review, audit, and dashboard"
      contains: "AuditLogEntry, DashboardStats, SplitRequest"
    - path: "frontend/src/api/client.ts"
      provides: "API client functions for review operations and dashboard"
      contains: "fetchReviewQueue, splitEvent, mergeEvents, fetchDashboardStats"
    - path: "frontend/src/hooks/useReview.ts"
      provides: "TanStack Query hooks for review queue and mutations"
      contains: "useReviewQueue, useSplitEvent, useMergeEvents"
    - path: "frontend/src/hooks/useDashboard.ts"
      provides: "TanStack Query hooks for dashboard data"
      contains: "useDashboardStats, useProcessingHistory"
    - path: "frontend/src/components/ReviewQueue.tsx"
      provides: "Review queue page with table, confidence indicators, and dismiss action"
    - path: "frontend/src/components/SplitDialog.tsx"
      provides: "Modal dialog for split operation with optional target search"
    - path: "frontend/src/components/MergeDialog.tsx"
      provides: "Modal dialog for merge operation with canonical event search"
    - path: "frontend/src/components/Dashboard.tsx"
      provides: "Dashboard page with stats cards, bar charts, and processing history"
    - path: "frontend/src/components/AuditTrail.tsx"
      provides: "Audit log display component for a canonical event"
    - path: "frontend/src/components/EventDetail.tsx"
      provides: "Extended with split/merge action buttons and audit trail section"
    - path: "frontend/src/App.tsx"
      provides: "Extended routes and navigation header"
    - path: "docker/nginx.conf"
      provides: "Updated nginx config proxying new API paths"
  key_links:
    - from: "frontend/src/hooks/useReview.ts"
      to: "frontend/src/api/client.ts"
      via: "useMutation calls splitEvent/mergeEvents/dismissFromQueue"
      pattern: "useMutation.*splitEvent|mergeEvents|dismissFromQueue"
    - from: "frontend/src/components/ReviewQueue.tsx"
      to: "frontend/src/hooks/useReview.ts"
      via: "useReviewQueue for data, useDismissEvent for action"
      pattern: "useReviewQueue|useDismissEvent"
    - from: "frontend/src/components/EventDetail.tsx"
      to: "frontend/src/components/SplitDialog.tsx"
      via: "SplitDialog rendered when split button clicked"
      pattern: "SplitDialog"
    - from: "frontend/src/components/EventDetail.tsx"
      to: "frontend/src/components/MergeDialog.tsx"
      via: "MergeDialog rendered when merge button clicked"
      pattern: "MergeDialog"
    - from: "frontend/src/components/EventDetail.tsx"
      to: "frontend/src/components/AuditTrail.tsx"
      via: "AuditTrail rendered at bottom of EventDetail"
      pattern: "AuditTrail"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/ReviewQueue.tsx"
      via: "Route path=/review element={ReviewQueue}"
      pattern: "ReviewQueue"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/Dashboard.tsx"
      via: "Route path=/dashboard element={Dashboard}"
      pattern: "Dashboard"
---

<objective>
Build the complete frontend for manual review operations: review queue page, split/merge dialogs, batch processing dashboard, audit trail component, and navigation updates. Also update nginx to proxy new API paths.

Purpose: This plan delivers the user-facing interfaces that operators use to correct grouping mistakes and monitor system health. All data comes from the API endpoints created in Plan 06-01.

Output: Five new React components (ReviewQueue, SplitDialog, MergeDialog, Dashboard, AuditTrail), extended types/client/hooks, updated EventDetail with action buttons, updated App with routes and navigation, updated nginx config.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06/06-RESEARCH.md
@.planning/phases/06/06-01-SUMMARY.md

@frontend/src/App.tsx
@frontend/src/types/index.ts
@frontend/src/api/client.ts
@frontend/src/hooks/useCanonicalEvents.ts
@frontend/src/components/EventDetail.tsx
@frontend/src/components/EventList.tsx
@frontend/src/components/ConfidenceIndicator.tsx
@frontend/src/components/Pagination.tsx
@frontend/src/components/SearchFilters.tsx
@docker/nginx.conf

<interfaces>
<!-- Key types and contracts from Plan 06-01 API endpoints. -->

API Endpoints (from 06-01):
```
POST /api/review/split     Body: {canonical_event_id, source_event_id, target_canonical_id?, operator?}  -> {original_canonical_id, new_canonical_id?, target_canonical_id?, original_deleted}
POST /api/review/merge     Body: {source_canonical_id, target_canonical_id, operator?}  -> {surviving_canonical_id, deleted_canonical_id, new_source_count}
GET  /api/review/queue     ?page=1&size=20&min_sources=1  -> PaginatedResponse<CanonicalEventSummary>
POST /api/review/queue/{id}/dismiss  Body: {operator?, reason?}  -> {status: "dismissed"}
GET  /api/audit-log        ?page=1&size=20&canonical_event_id=N&action_type=split  -> PaginatedResponse<AuditLogEntry>
GET  /api/dashboard/stats  ?days=30  -> {files: {total_files, total_events, completed, errors}, matches: {match, no_match, ambiguous}, canonicals: {total, needs_review, avg_confidence}}
GET  /api/dashboard/processing-history  ?days=30&granularity=day  -> [{date, files_processed, events_ingested, errors}]
```

Existing Frontend Patterns:
```typescript
// API client pattern (from client.ts):
const API_BASE = '/api';
export async function fetchCanonicalEvents(...): Promise<PaginatedResponse<CanonicalEventSummary>> {
  const res = await fetch(`${API_BASE}/canonical-events?${params}`);
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}

// Hook pattern (from useCanonicalEvents.ts):
export function useCanonicalEvents(filters, page, size) {
  return useQuery({
    queryKey: ['canonical-events', filters, page, size],
    queryFn: () => fetchCanonicalEvents(filters, page, size),
    placeholderData: keepPreviousData,
  });
}

// Mutation pattern (from 06-RESEARCH.md):
export function useSplitEvent() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: splitEvent,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['canonical-events'] });
      queryClient.invalidateQueries({ queryKey: ['canonical-event'] });
      queryClient.invalidateQueries({ queryKey: ['review-queue'] });
    },
  });
}
```

Existing TypeScript Types (from types/index.ts):
```typescript
export interface CanonicalEventSummary {
  id: number; title: string; location_city: string | null;
  dates: EventDate[] | null; categories: string[] | null;
  source_count: number; match_confidence: number | null; needs_review: boolean;
}
export interface PaginatedResponse<T> {
  items: T[]; total: number; page: number; size: number; pages: number;
}
```

Existing Components:
- Pagination.tsx: `<Pagination page={p} pages={n} total={t} onPageChange={fn} />`
- SearchFilters.tsx: filter bar component
- ConfidenceIndicator.tsx: ScoreBar component using Tailwind bars
- EventDetail.tsx: detail page with header, details, sources, match scores sections
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, API client, hooks, and nginx config</name>
  <files>
    frontend/src/types/index.ts
    frontend/src/api/client.ts
    frontend/src/hooks/useReview.ts
    frontend/src/hooks/useDashboard.ts
    docker/nginx.conf
  </files>
  <action>
    **1. Extend `frontend/src/types/index.ts`:**

    Add the following types at the bottom of the file (after existing `EventFilters` interface):

    ```typescript
    // --- Review operation types ---

    export interface SplitRequest {
      canonical_event_id: number;
      source_event_id: string;
      target_canonical_id?: number | null;
      operator?: string;
    }

    export interface SplitResponse {
      original_canonical_id: number;
      new_canonical_id: number | null;
      target_canonical_id: number | null;
      original_deleted: boolean;
    }

    export interface MergeRequest {
      source_canonical_id: number;
      target_canonical_id: number;
      operator?: string;
    }

    export interface MergeResponse {
      surviving_canonical_id: number;
      deleted_canonical_id: number;
      new_source_count: number;
    }

    export interface DismissRequest {
      operator?: string;
      reason?: string;
    }

    export interface AuditLogEntry {
      id: number;
      action_type: string;
      canonical_event_id: number | null;
      source_event_id: string | null;
      operator: string;
      details: Record<string, unknown> | null;
      created_at: string;
    }

    // --- Dashboard types ---

    export interface FileProcessingStats {
      total_files: number;
      total_events: number;
      completed: number;
      errors: number;
    }

    export interface MatchDistribution {
      match: number;
      no_match: number;
      ambiguous: number;
    }

    export interface CanonicalStats {
      total: number;
      needs_review: number;
      avg_confidence: number | null;
    }

    export interface DashboardStats {
      files: FileProcessingStats;
      matches: MatchDistribution;
      canonicals: CanonicalStats;
    }

    export interface ProcessingHistoryEntry {
      date: string;
      files_processed: number;
      events_ingested: number;
      errors: number;
    }
    ```

    **2. Extend `frontend/src/api/client.ts`:**

    Add the following API functions after the existing `fetchCanonicalEventDetail`:

    ```typescript
    import type {
      CanonicalEventDetail, CanonicalEventSummary, EventFilters, PaginatedResponse,
      SplitRequest, SplitResponse, MergeRequest, MergeResponse,
      DismissRequest, AuditLogEntry, DashboardStats, ProcessingHistoryEntry,
    } from '../types';

    // --- Review operations ---

    export async function fetchReviewQueue(
      page: number = 1,
      size: number = 20,
      minSources: number = 1,
    ): Promise<PaginatedResponse<CanonicalEventSummary>> {
      const params = new URLSearchParams({
        page: String(page),
        size: String(size),
        min_sources: String(minSources),
      });
      const res = await fetch(`${API_BASE}/review/queue?${params}`);
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return res.json();
    }

    export async function splitEvent(request: SplitRequest): Promise<SplitResponse> {
      const res = await fetch(`${API_BASE}/review/split`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({ detail: `HTTP ${res.status}` }));
        throw new Error(err.detail || `API error: ${res.status}`);
      }
      return res.json();
    }

    export async function mergeEvents(request: MergeRequest): Promise<MergeResponse> {
      const res = await fetch(`${API_BASE}/review/merge`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({ detail: `HTTP ${res.status}` }));
        throw new Error(err.detail || `API error: ${res.status}`);
      }
      return res.json();
    }

    export async function dismissFromQueue(
      eventId: number,
      request: DismissRequest = {},
    ): Promise<{ status: string }> {
      const res = await fetch(`${API_BASE}/review/queue/${eventId}/dismiss`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return res.json();
    }

    export async function fetchAuditLog(
      page: number = 1,
      size: number = 20,
      canonicalEventId?: number,
      actionType?: string,
    ): Promise<PaginatedResponse<AuditLogEntry>> {
      const params = new URLSearchParams({ page: String(page), size: String(size) });
      if (canonicalEventId) params.set('canonical_event_id', String(canonicalEventId));
      if (actionType) params.set('action_type', actionType);
      const res = await fetch(`${API_BASE}/audit-log?${params}`);
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return res.json();
    }

    // --- Dashboard ---

    export async function fetchDashboardStats(days: number = 30): Promise<DashboardStats> {
      const res = await fetch(`${API_BASE}/dashboard/stats?days=${days}`);
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return res.json();
    }

    export async function fetchProcessingHistory(
      days: number = 30,
      granularity: string = 'day',
    ): Promise<ProcessingHistoryEntry[]> {
      const res = await fetch(`${API_BASE}/dashboard/processing-history?days=${days}&granularity=${granularity}`);
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return res.json();
    }

    // --- Search helper for merge/split dialogs ---

    export async function searchCanonicalEvents(
      q: string,
      size: number = 10,
    ): Promise<PaginatedResponse<CanonicalEventSummary>> {
      const params = new URLSearchParams({ q, page: '1', size: String(size) });
      const res = await fetch(`${API_BASE}/canonical-events?${params}`);
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      return res.json();
    }
    ```

    **3. Create `frontend/src/hooks/useReview.ts`:**

    ```typescript
    import { useMutation, useQuery, useQueryClient, keepPreviousData } from '@tanstack/react-query';
    import {
      fetchReviewQueue, splitEvent, mergeEvents, dismissFromQueue, fetchAuditLog,
    } from '../api/client';
    import type { SplitRequest, MergeRequest, DismissRequest } from '../types';

    export function useReviewQueue(page: number, size: number = 20, minSources: number = 1) {
      return useQuery({
        queryKey: ['review-queue', page, size, minSources],
        queryFn: () => fetchReviewQueue(page, size, minSources),
        placeholderData: keepPreviousData,
      });
    }

    export function useSplitEvent() {
      const queryClient = useQueryClient();
      return useMutation({
        mutationFn: (params: SplitRequest) => splitEvent(params),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['canonical-events'] });
          queryClient.invalidateQueries({ queryKey: ['canonical-event'] });
          queryClient.invalidateQueries({ queryKey: ['review-queue'] });
          queryClient.invalidateQueries({ queryKey: ['audit-log'] });
        },
      });
    }

    export function useMergeEvents() {
      const queryClient = useQueryClient();
      return useMutation({
        mutationFn: (params: MergeRequest) => mergeEvents(params),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['canonical-events'] });
          queryClient.invalidateQueries({ queryKey: ['canonical-event'] });
          queryClient.invalidateQueries({ queryKey: ['review-queue'] });
          queryClient.invalidateQueries({ queryKey: ['audit-log'] });
        },
      });
    }

    export function useDismissEvent() {
      const queryClient = useQueryClient();
      return useMutation({
        mutationFn: ({ eventId, ...request }: DismissRequest & { eventId: number }) =>
          dismissFromQueue(eventId, request),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['review-queue'] });
          queryClient.invalidateQueries({ queryKey: ['canonical-event'] });
          queryClient.invalidateQueries({ queryKey: ['audit-log'] });
        },
      });
    }

    export function useAuditLog(canonicalEventId?: number, page: number = 1, size: number = 20) {
      return useQuery({
        queryKey: ['audit-log', canonicalEventId, page, size],
        queryFn: () => fetchAuditLog(page, size, canonicalEventId),
        placeholderData: keepPreviousData,
      });
    }
    ```

    **4. Create `frontend/src/hooks/useDashboard.ts`:**

    ```typescript
    import { useQuery } from '@tanstack/react-query';
    import { fetchDashboardStats, fetchProcessingHistory } from '../api/client';

    export function useDashboardStats(days: number = 30) {
      return useQuery({
        queryKey: ['dashboard-stats', days],
        queryFn: () => fetchDashboardStats(days),
      });
    }

    export function useProcessingHistory(days: number = 30, granularity: string = 'day') {
      return useQuery({
        queryKey: ['processing-history', days, granularity],
        queryFn: () => fetchProcessingHistory(days, granularity),
      });
    }
    ```

    **5. Update `docker/nginx.conf`:**

    The existing config already has `location /api/` which proxies ALL `/api/*` requests to the API container. This means `/api/review/*`, `/api/dashboard/*`, and `/api/audit-log*` will already be proxied correctly. **No changes needed** -- verify this is the case by reading the file. The existing rule `location /api/ { proxy_pass http://api:8000/api/; }` covers all sub-paths.

    If for any reason the existing config does NOT cover all `/api/*` sub-paths, add explicit blocks. But based on the current nginx config, it already does. Still, read the file and confirm -- if confirmed, no modification needed.
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` -- TypeScript compilation succeeds with no errors.
  </verify>
  <done>
    All TypeScript types for review operations, audit log, and dashboard are defined. API client has functions for all 06-01 endpoints. TanStack Query hooks provide useReviewQueue, useSplitEvent, useMergeEvents, useDismissEvent, useAuditLog, useDashboardStats, useProcessingHistory -- all with proper cache invalidation on mutations. Nginx config confirmed to proxy all /api/* paths.
  </done>
</task>

<task type="auto">
  <name>Task 2: ReviewQueue, SplitDialog, MergeDialog, AuditTrail, Dashboard components</name>
  <files>
    frontend/src/components/ReviewQueue.tsx
    frontend/src/components/SplitDialog.tsx
    frontend/src/components/MergeDialog.tsx
    frontend/src/components/AuditTrail.tsx
    frontend/src/components/Dashboard.tsx
  </files>
  <action>
    **1. Create `frontend/src/components/ReviewQueue.tsx`:**

    A page component at route `/review`. Follow the EventList.tsx pattern: table layout, pagination, URL search params for page state.

    Structure:
    - Header: "Review Queue" title with count badge showing total items
    - Table columns: Title (link to /events/:id), City, Confidence (colored like EventList), Sources, Actions
    - Confidence column: show percentage with color coding (red < 50%, yellow 50-80%, green >= 80%)
    - Actions column: "Dismiss" button (small, gray) that calls `useDismissEvent` mutation
    - needs_review badge shown on items that have the flag set
    - Pagination at bottom using existing `<Pagination>` component
    - Empty state: "No events need review." when queue is empty
    - Loading/error states matching EventList patterns

    Use `useReviewQueue(page)` hook. Use `useSearchParams` for page state like EventList does.

    **2. Create `frontend/src/components/SplitDialog.tsx`:**

    A modal dialog component. Props: `{ canonicalEventId: number, sourceEventId: string, sourceTitle: string, onClose: () => void, onSuccess: () => void }`.

    Structure:
    - Overlay backdrop (fixed inset-0, bg-black/50, z-50)
    - White modal card (centered, max-w-lg)
    - Header: "Split Source Event" + source title
    - Two radio options:
      1. "Create new canonical event" (default)
      2. "Assign to existing canonical event" -- when selected, shows a search input
    - Search input: debounced text input (300ms) that calls `searchCanonicalEvents(q)` from the API client. Show results as a selectable list below the input. Each result shows: title, city, source_count. Clicking a result selects it (highlighted border).
    - Optional "Operator" text input (small, at bottom)
    - Buttons: "Cancel" (gray) and "Split" (blue, disabled while loading)
    - On submit: call `useSplitEvent().mutateAsync(...)`. On success, call `onSuccess()`. On error, show error message inline.

    Use `useState` for form state, `useSplitEvent` hook for the mutation, and direct `searchCanonicalEvents` call for the search (no need for a dedicated hook -- use `useQuery` inline or just `useState` + `useEffect` with the API call).

    For the search, a simple approach: `useQuery` with `queryKey: ['search-canonicals', debouncedQuery]` and `enabled: debouncedQuery.length >= 2`. Use a `useEffect` + `setTimeout` for debouncing.

    **3. Create `frontend/src/components/MergeDialog.tsx`:**

    A modal dialog component. Props: `{ canonicalEventId: number, canonicalTitle: string, onClose: () => void, onSuccess: () => void }`.

    Structure:
    - Same overlay/modal pattern as SplitDialog
    - Header: "Merge with Another Event"
    - Current event shown: title (readonly info)
    - Search input for the target canonical event (same debounced search pattern as SplitDialog)
    - Search results list: each shows title, city, source_count. Clicking selects it.
    - Direction indicator: "Merging [current title] INTO [selected title]" -- the current event is the donor (will be deleted), the selected event is the target (survives). This matches the API semantics: source_canonical_id (donor) = current, target_canonical_id (survivor) = selected.
    - Optional "Operator" text input
    - Buttons: "Cancel" and "Merge" (red/orange to indicate destructive action, disabled while loading)
    - On submit: call `useMergeEvents().mutateAsync(...)`. On success, navigate to the surviving canonical event's detail page (use `useNavigate` from react-router-dom) since the current event will be deleted.
    - On error, show error message inline.

    **4. Create `frontend/src/components/AuditTrail.tsx`:**

    A display component. Props: `{ canonicalEventId: number }`.

    Structure:
    - Uses `useAuditLog(canonicalEventId)` to fetch audit entries for this event
    - If no entries: show "No audit history." in gray italic
    - If entries exist: show a simple timeline/list:
      - Each entry: colored left border (blue for split, green for merge, gray for dismiss), action_type badge, operator name, relative or absolute timestamp, details summary
      - Action type formatting: "split" -> "Split", "merge" -> "Merge", "review_dismiss" -> "Dismissed"
      - Details summary: for split show "Detached source {source_event_id}", for merge show "Merged from canonical #{details.deleted_canonical_id}", for dismiss show reason if provided
      - Timestamp: format with date-fns `format(parseISO(...), 'dd.MM.yyyy HH:mm')`
    - No pagination needed (audit log for a single event is typically small)

    **5. Create `frontend/src/components/Dashboard.tsx`:**

    A page component at route `/dashboard`.

    Structure:
    - Header: "Processing Dashboard" title
    - Time range selector: buttons for 7 days, 30 days, 90 days (default 30). Use `useState`.
    - **Stats cards row** (grid, 4 columns on lg, 2 on md, 1 on sm):
      1. "Files Processed" -- `stats.files.total_files` with `stats.files.completed` completed / `stats.files.errors` errors subtitle
      2. "Events Ingested" -- `stats.files.total_events`
      3. "Canonical Events" -- `stats.canonicals.total` with `stats.canonicals.needs_review` needing review subtitle
      4. "Avg Confidence" -- `stats.canonicals.avg_confidence` formatted as percentage
    - **Match Distribution section** -- horizontal bar chart using Tailwind (like ScoreBar pattern):
      - Three bars: Match (green), No Match (gray), Ambiguous (yellow)
      - Each bar: label, count, percentage width based on total
      - Use the same `bg-green-500`, `bg-gray-400`, `bg-yellow-500` pattern from ConfidenceIndicator
    - **Processing History section** -- simple bar chart for daily trend:
      - For each day in history: a row with date label, and stacked/grouped bars for files_processed and events_ingested
      - Use simple div bars with Tailwind (no charting library)
      - Scale bars relative to the max value in the dataset
      - Show errors as a small red indicator if > 0
      - If no history data: "No processing data available."
    - Loading/error states

    Use `useDashboardStats(days)` and `useProcessingHistory(days)` hooks.
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` -- TypeScript compilation succeeds.
    Run `cd frontend && npx vite build` -- production build succeeds with no errors.
  </verify>
  <done>
    ReviewQueue page displays low-confidence events with dismiss action. SplitDialog allows detaching a source with optional target assignment via search. MergeDialog allows combining two canonicals via search with clear direction indicator. AuditTrail shows timestamped operation log. Dashboard shows stats cards, match distribution bars, and daily processing trend.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire components into EventDetail and App routes/navigation</name>
  <files>
    frontend/src/components/EventDetail.tsx
    frontend/src/App.tsx
  </files>
  <action>
    **1. Update `frontend/src/components/EventDetail.tsx`:**

    Add the following changes to the existing EventDetail component:

    **Imports to add:**
    ```typescript
    import { useState } from 'react';
    import { SplitDialog } from './SplitDialog';
    import { MergeDialog } from './MergeDialog';
    import { AuditTrail } from './AuditTrail';
    ```

    **State variables** (inside the component function):
    ```typescript
    const [splitSource, setSplitSource] = useState<{ id: string; title: string } | null>(null);
    const [showMerge, setShowMerge] = useState(false);
    ```

    **Add action buttons in Section 1 (Header):**

    After the existing badge row (the `<div className="flex flex-wrap gap-2">` containing source count and confidence badges), add a new row of action buttons:

    ```tsx
    {/* Review actions */}
    {detail.source_count > 1 && (
      <div className="mt-3 pt-3 border-t flex gap-2">
        <button
          onClick={() => setShowMerge(true)}
          className="text-sm px-3 py-1.5 bg-orange-50 text-orange-700 border border-orange-200 rounded hover:bg-orange-100"
        >
          Merge with...
        </button>
      </div>
    )}
    {detail.source_count <= 1 && (
      <div className="mt-3 pt-3 border-t flex gap-2">
        <button
          onClick={() => setShowMerge(true)}
          className="text-sm px-3 py-1.5 bg-orange-50 text-orange-700 border border-orange-200 rounded hover:bg-orange-100"
        >
          Merge with...
        </button>
      </div>
    )}
    ```

    Actually, simplify: always show the "Merge with..." button. It works for any canonical event.

    ```tsx
    <div className="mt-3 pt-3 border-t flex gap-2">
      <button
        onClick={() => setShowMerge(true)}
        className="text-sm px-3 py-1.5 bg-orange-50 text-orange-700 border border-orange-200 rounded hover:bg-orange-100"
      >
        Merge with...
      </button>
    </div>
    ```

    **Add Split buttons per source event in Section 3 (Source Events):**

    In the SourceComparison section, we need to add a "Split" button per source. However, SourceComparison is a separate component. Two approaches:
    - (a) Modify SourceComparison to accept an `onSplit` callback -- more coupling.
    - (b) Render the sources inline in EventDetail with split buttons -- duplicates layout.
    - (c) Add a row of split buttons below the SourceComparison component.

    **Best approach:** Add a "Split" button row below the SourceComparison component, only when there are 2+ sources. List each source with a small "Detach" button:

    ```tsx
    {detail.sources.length >= 2 && (
      <div className="mt-4 pt-4 border-t">
        <h4 className="text-sm font-medium text-gray-700 mb-2">Detach source event:</h4>
        <div className="flex flex-wrap gap-2">
          {detail.sources.map((s) => (
            <button
              key={s.id}
              onClick={() => setSplitSource({ id: s.id, title: s.title })}
              className="text-xs px-2 py-1 bg-red-50 text-red-700 border border-red-200 rounded hover:bg-red-100"
            >
              Split: {s.title.length > 40 ? s.title.slice(0, 40) + '...' : s.title}
            </button>
          ))}
        </div>
      </div>
    )}
    ```

    Place this INSIDE the Section 3 card (after `<SourceComparison sources={detail.sources} />`).

    **Add Section 5: Audit Trail** at the bottom of the component (after the Match Scores section):

    ```tsx
    {/* Section 5: Audit Trail */}
    <div className="bg-white rounded-lg shadow-sm border p-6">
      <h3 className="text-lg font-semibold text-gray-900 mb-4">Audit Trail</h3>
      <AuditTrail canonicalEventId={eventId} />
    </div>
    ```

    **Render dialogs** at the bottom of the JSX return (before the closing `</div>`):

    ```tsx
    {splitSource && (
      <SplitDialog
        canonicalEventId={eventId}
        sourceEventId={splitSource.id}
        sourceTitle={splitSource.title}
        onClose={() => setSplitSource(null)}
        onSuccess={() => setSplitSource(null)}
      />
    )}
    {showMerge && (
      <MergeDialog
        canonicalEventId={eventId}
        canonicalTitle={detail.title}
        onClose={() => setShowMerge(false)}
        onSuccess={() => setShowMerge(false)}
      />
    )}
    ```

    Note: After a successful merge, the MergeDialog should navigate to the surviving event. The MergeDialog component handles this internally using `useNavigate`.

    **2. Update `frontend/src/App.tsx`:**

    **Add imports:**
    ```typescript
    import { Link } from 'react-router-dom';  // Already imported via BrowserRouter
    import { ReviewQueue } from './components/ReviewQueue';
    import { Dashboard } from './components/Dashboard';
    ```

    Note: `Link` is already available since `react-router-dom` is imported. We need to use `Link` for navigation.

    **Update the header** to add navigation links. Replace the current header content:

    ```tsx
    <header className="bg-white shadow-sm border-b">
      <div className="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
        <h1 className="text-xl font-semibold text-gray-900">
          <a href="/" className="hover:text-blue-600">Event Deduplication</a>
        </h1>
        <nav className="flex gap-4">
          <Link to="/" className="text-sm text-gray-600 hover:text-blue-600">
            Events
          </Link>
          <Link to="/review" className="text-sm text-gray-600 hover:text-blue-600">
            Review Queue
          </Link>
          <Link to="/dashboard" className="text-sm text-gray-600 hover:text-blue-600">
            Dashboard
          </Link>
        </nav>
      </div>
    </header>
    ```

    **Add new routes** inside `<Routes>`:
    ```tsx
    <Route path="/review" element={<ReviewQueue />} />
    <Route path="/dashboard" element={<Dashboard />} />
    ```

    Place these after the existing `/events/:id` route.
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` -- TypeScript compilation succeeds.
    Run `cd frontend && npx vite build` -- production build succeeds with no errors.
  </verify>
  <done>
    EventDetail page has "Merge with..." button in header, per-source "Split" buttons in the sources section (only when 2+ sources), and an Audit Trail section at the bottom. SplitDialog and MergeDialog modals render when triggered. App.tsx has /review and /dashboard routes and navigation links in the header. Frontend builds successfully.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` -- TypeScript compilation succeeds
2. `cd frontend && npx vite build` -- production build succeeds
3. Visual check: Navigate to `/review` -- review queue page renders
4. Visual check: Navigate to `/dashboard` -- dashboard page renders with stats cards and processing history
5. Visual check: Navigate to `/events/:id` -- split buttons appear per source (when 2+ sources), merge button always visible, audit trail section at bottom
6. Functional: Click "Split" on a source event in EventDetail -- SplitDialog opens with option to create new or assign to existing
7. Functional: Click "Merge with..." on EventDetail -- MergeDialog opens with search for target canonical
8. Functional: Click "Dismiss" on a review queue item -- item removed from queue
</verification>

<success_criteria>
- /review route shows review queue page with low-confidence events sorted by uncertainty, paginated, with dismiss action
- /dashboard route shows dashboard page with stats cards (files processed, events ingested, canonical events, avg confidence), match distribution bars, and daily processing history
- EventDetail has split buttons per source event (visible when 2+ sources), merge button, and audit trail section
- SplitDialog allows creating new canonical or assigning to existing via search
- MergeDialog allows selecting target canonical via search and executes merge
- After any mutation (split/merge/dismiss), affected queries are invalidated and UI refreshes
- Navigation header includes Events, Review Queue, Dashboard links
- Frontend TypeScript compiles without errors
- Frontend production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06/06-02-SUMMARY.md`
</output>
