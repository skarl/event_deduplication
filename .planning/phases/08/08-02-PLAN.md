---
phase: 08-dynamic-config
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/types/index.ts
  - frontend/src/api/client.ts
  - frontend/src/hooks/useConfig.ts
  - frontend/src/components/ConfigPage.tsx
  - frontend/src/App.tsx
autonomous: false
requirements:
  - CFG-02
  - CFG-03
  - CFG-04
  - CFG-05

must_haves:
  truths:
    - "Operator can view all matching parameters organized in grouped sections"
    - "Operator can edit any matching parameter and save changes"
    - "Operator can enter a Gemini API key that is masked after saving"
    - "Operator can toggle AI matching on/off via a visible switch"
    - "Config page is accessible from the main navigation"
    - "Scoring weights show a live sum with validation warning if not 1.0"
  artifacts:
    - path: "frontend/src/components/ConfigPage.tsx"
      provides: "Grouped config editor with 7 sections"
      min_lines: 200
    - path: "frontend/src/hooks/useConfig.ts"
      provides: "TanStack Query hooks for config CRUD"
      exports: ["useConfig", "useUpdateConfig"]
    - path: "frontend/src/api/client.ts"
      provides: "fetchConfig and updateConfig API functions"
      contains: "fetchConfig"
  key_links:
    - from: "frontend/src/components/ConfigPage.tsx"
      to: "frontend/src/hooks/useConfig.ts"
      via: "useConfig and useUpdateConfig hooks"
      pattern: "useConfig|useUpdateConfig"
    - from: "frontend/src/hooks/useConfig.ts"
      to: "frontend/src/api/client.ts"
      via: "fetchConfig and updateConfig functions"
      pattern: "fetchConfig|updateConfig"
    - from: "frontend/src/api/client.ts"
      to: "/api/config"
      via: "fetch GET and PATCH"
      pattern: "api/config"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/ConfigPage.tsx"
      via: "React Router route"
      pattern: "/config"
---

<objective>
Build the frontend configuration page where operators can view and edit all matching parameters, manage the Gemini API key (write-only), and toggle AI matching on/off.

Purpose: Give operators a visual interface to tune all matching parameters without editing YAML files or restarting the worker. The config page must be grouped into logical sections matching the MatchingConfig model structure.

Output: Fully functional ConfigPage component with 7 grouped sections, integrated into the app routing and navigation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08/08-RESEARCH.md
@.planning/phases/08/08-01-SUMMARY.md

@frontend/src/App.tsx
@frontend/src/api/client.ts
@frontend/src/types/index.ts
@frontend/src/hooks/useCanonicalEvents.ts

<interfaces>
<!-- From Plan 01: API contract the frontend will consume -->

GET /api/config returns:
```typescript
interface AIConfigResponse {
  enabled: boolean;
  model: string;
  temperature: number;
  max_output_tokens: number;
  max_concurrent_requests: number;
  confidence_threshold: number;
  cache_enabled: boolean;
  cost_per_1m_input_tokens: number;
  cost_per_1m_output_tokens: number;
}

interface ScoringWeights {
  date: number;
  geo: number;
  title: number;
  description: number;
}

interface ThresholdConfig {
  high: number;
  low: number;
}

interface GeoConfig {
  max_distance_km: number;
  min_confidence: number;
  neutral_score: number;
}

interface DateConfig {
  time_tolerance_minutes: number;
  time_close_minutes: number;
  close_factor: number;
  far_factor: number;
}

interface TitleConfig {
  primary_weight: number;
  secondary_weight: number;
  blend_lower: number;
  blend_upper: number;
  cross_source_type: TitleConfig | null;
}

interface ClusterConfig {
  max_cluster_size: number;
  min_internal_similarity: number;
}

interface FieldStrategies {
  title: string;
  short_description: string;
  description: string;
  highlights: string;
  location_name: string;
  location_city: string;
  location_street: string;
  geo: string;
  categories: string;
  is_family_event: string;
  is_child_focused: string;
  admission_free: string;
}

interface CanonicalConfig {
  field_strategies: FieldStrategies;
}

interface CategoryWeightsConfig {
  priority: string[];
  overrides: Record<string, ScoringWeights>;
}

interface ConfigResponse {
  scoring: ScoringWeights;
  thresholds: ThresholdConfig;
  geo: GeoConfig;
  date: DateConfig;
  title: TitleConfig;
  cluster: ClusterConfig;
  canonical: CanonicalConfig;
  ai: AIConfigResponse;
  category_weights: CategoryWeightsConfig;
  has_api_key: boolean;
  updated_at: string | null;
}
```

PATCH /api/config accepts partial updates:
```typescript
interface ConfigUpdateRequest {
  scoring?: Partial<ScoringWeights>;
  thresholds?: Partial<ThresholdConfig>;
  geo?: Partial<GeoConfig>;
  date?: Partial<DateConfig>;
  title?: Partial<TitleConfig>;
  cluster?: Partial<ClusterConfig>;
  canonical?: Partial<CanonicalConfig>;
  ai?: Partial<AIConfigResponse>;
  category_weights?: Partial<CategoryWeightsConfig>;
  ai_api_key?: string;  // Write-only, top-level
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript types, API client, and TanStack Query hooks</name>
  <files>
    frontend/src/types/index.ts
    frontend/src/api/client.ts
    frontend/src/hooks/useConfig.ts
  </files>
  <action>
1. Add config types to `frontend/src/types/index.ts` (append, do not modify existing types):
   - `ScoringWeights`, `ThresholdConfig`, `GeoConfig`, `DateConfig`, `TitleConfig`, `ClusterConfig`, `FieldStrategies`, `CanonicalConfig`, `AIConfigResponse`, `CategoryWeightsConfig` -- matching the interfaces block above.
   - `ConfigResponse` with all section fields plus `has_api_key: boolean` and `updated_at: string | null`.
   - `ConfigUpdateRequest` with all sections as optional partials, plus `ai_api_key?: string`.

2. Add API functions to `frontend/src/api/client.ts` (append, do not modify existing functions):
   - `fetchConfig(): Promise<ConfigResponse>` -- GET /api/config, throw on non-OK.
   - `updateConfig(updates: ConfigUpdateRequest): Promise<ConfigResponse>` -- PATCH /api/config with JSON body, throw on non-OK.

3. Create `frontend/src/hooks/useConfig.ts`:
   - `useConfig()`: TanStack Query hook using `useQuery` with queryKey `['config']`, queryFn calling `fetchConfig`. Use `staleTime: 60_000` (config doesn't change frequently).
   - `useUpdateConfig()`: TanStack Query `useMutation` calling `updateConfig`, with `onSuccess` invalidating the `['config']` queryKey via `queryClient.invalidateQueries()`. Use `useQueryClient()` to get the query client.

   Follow the exact pattern from `useCanonicalEvents.ts` for the query hook. For the mutation, follow TanStack Query v5 patterns:
   ```typescript
   import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
   ```
  </action>
  <verify>
    <automated>cd /Users/svenkarl/workspaces/event-deduplication/frontend && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>Config types exported from types/index.ts, fetchConfig/updateConfig in client.ts, useConfig/useUpdateConfig hooks in useConfig.ts. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: ConfigPage component with grouped sections and route wiring</name>
  <files>
    frontend/src/components/ConfigPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
1. Create `frontend/src/components/ConfigPage.tsx` with the following structure:

   **Main component** `ConfigPage`:
   - Uses `useConfig()` for data loading and `useUpdateConfig()` for saving.
   - Shows loading state while fetching.
   - Renders 7 collapsible sections (use HTML `<details>` with `<summary>` or simple toggle state), all expanded by default.
   - Each section has a "Save" button that calls `updateConfig.mutate()` with only that section's data.
   - Show a success toast/banner on save (simple green notification that auto-dismisses after 3 seconds using local state, no need for a toast library).
   - Show error message on save failure.
   - Display `updated_at` timestamp at the top if config has been modified.

   **Section components** (can be inline in the same file or extracted -- use your judgment for readability):

   a. **Scoring Weights Section**: 4 number inputs (date, geo, title, description) each with `step="0.05"` and `min="0"` `max="1.0"`. Show a **live sum** below the inputs. If sum != 1.0, show a yellow warning: "Weights sum to {sum} (should be 1.0)". Use Tailwind for styling.

   b. **Thresholds Section**: 2 number inputs (high, low) with `step="0.05"`, `min="0"`, `max="1.0"`. Add a note: "High = auto-match, Low = auto-reject, Between = ambiguous".

   c. **Date/Time Section**: 4 inputs: `time_tolerance_minutes` (integer), `time_close_minutes` (integer), `close_factor` (float 0-1), `far_factor` (float 0-1). Label each clearly: "Exact match tolerance (minutes)", "Close match window (minutes)", "Close time factor", "Far time factor".

   d. **Geographic Section**: 3 inputs: `max_distance_km` (float), `min_confidence` (float 0-1), `neutral_score` (float 0-1). Labels: "Max distance (km)", "Min geo confidence", "Neutral score (when no geo data)".

   e. **Title Matching Section**: 4 inputs: `primary_weight`, `secondary_weight` (floats), `blend_lower`, `blend_upper` (floats). If `cross_source_type` is not null, show its fields in a sub-section labeled "Cross-source-type overrides" (read-only display is sufficient for cross_source_type).

   f. **AI Matching Section**:
      - Toggle switch for `enabled` (use a styled checkbox or button that looks like a toggle).
      - **API Key field**: `type="password"` input. If `has_api_key` is true and the input is empty, show placeholder "Key is set (enter new value to change)". Include a "Clear Key" button that sends `ai_api_key: ""`.
      - Model name input (text), temperature (number, step 0.05), max_output_tokens (number), confidence_threshold (number, step 0.05), cache_enabled (checkbox).
      - Note: When saving the AI section, if the api key input has a value, include it as `ai_api_key` in the PATCH. If empty and key was already set, don't include `ai_api_key` (don't accidentally clear it).

   g. **Clustering Section**: 2 inputs: `max_cluster_size` (integer), `min_internal_similarity` (float 0-1).

   **Styling**: Use the existing Tailwind patterns from the project. Each section in a white card with shadow (`bg-white rounded-lg shadow-sm p-6`). Section headers bold. Inputs with Tailwind form styling (`border rounded px-3 py-2`). Labels as `text-sm font-medium text-gray-700`.

   Category weights and canonical field strategies: Include as read-only sections at the bottom. Display category_weights.priority as a comma-separated list and overrides as a simple JSON dump. Display field_strategies as a key-value table. Label these sections as "Advanced (read-only)".

2. Wire into `frontend/src/App.tsx`:
   - Import `ConfigPage` from `./components/ConfigPage`.
   - Add route: `<Route path="/config" element={<ConfigPage />} />`.
   - Add nav link: `<Link to="/config" ...>Config</Link>` in the nav bar alongside Events, Review Queue, Dashboard.
  </action>
  <verify>
    <automated>cd /Users/svenkarl/workspaces/event-deduplication/frontend && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>ConfigPage renders 7 grouped sections with editable inputs, per-section save buttons, live scoring weight sum validation, write-only API key field, AI toggle, and read-only advanced sections. Route /config and nav link added to App.tsx. TypeScript compiles clean.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete dynamic configuration system: backend API (GET/PATCH /api/config with encrypted API key storage) + frontend config page with 7 grouped sections, live validation, write-only API key, AI toggle.</what-built>
  <how-to-verify>
    1. Start the backend: `cd /Users/svenkarl/workspaces/event-deduplication && docker compose up -d db && uv run alembic upgrade head && uv run uvicorn event_dedup.api.app:app --reload`
    2. Start the frontend: `cd frontend && npm run dev`
    3. Navigate to http://localhost:5173/config
    4. Verify: Config page loads with all 7 sections showing default values
    5. Change a scoring weight (e.g., date to 0.40) and click Save -- verify success notification and the sum warning updates
    6. Reload the page -- verify the changed value persists
    7. In AI section: toggle "enabled" on, enter an API key, save -- verify has_api_key shows as set, the key field shows masked placeholder
    8. Click "Clear Key" -- verify has_api_key resets
    9. Check that other nav links (Events, Review Queue, Dashboard) still work
    10. Run `curl http://localhost:8000/api/config | python -m json.tool` and confirm no api_key field in response
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` -- TypeScript compiles without errors
2. Frontend config page loads at /config with all sections
3. Editing and saving values persists them via API
4. API key is write-only (never visible after save)
5. Scoring weight sum validation shows warning when != 1.0
6. AI toggle visually reflects enabled/disabled state
</verification>

<success_criteria>
- Config page accessible from navigation at /config
- All 7 config sections render with current values
- Per-section save persists changes to database via PATCH API
- API key field is write-only with masked placeholder when set
- AI enabled toggle works and persists
- Scoring weight sum shows live validation
- Category weights and field strategies displayed as read-only
- Page reloads show persisted values
</success_criteria>

<output>
After completion, create `.planning/phases/08/08-02-SUMMARY.md`
</output>
